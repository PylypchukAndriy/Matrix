------
      |
 SDLC |
      |
------

Набір етапів робіт, що проводяться у заданому порядку протягом періоду часу, який починається з вирішення питання про розроблення програмного забезпечення і закінчується припиненням
використання програмного забезпечення. Існує безліч моделей, які описують процес розробки ПЗ(waterfall, iterative, incremental, spiral, agile, V-model, RAD).
Output попереднього етапу використовується у наступному.
Етапи:
1) Project Kickoff / Project Initiation
Перший етап при ініціації проекту. High level пленінг.

2) Requirements Gathering
На цьому етапі відбувається збирання функціональних та нефункціональних вимог від кастомера.
What is needed?
What is not needed?

3) Analysis
На даному етапі аналізуються зібрані вимоги та чи можуть бути вони реалізовані. Requirements Gathering & Analysis може відбуватись одночасно.

4) Design
Визначаються технології, що будуть використовуватись, архітектура застосунку, high-low level design.

5) Development
На цьому етапі пишеться код та створюються unit-тести.

6) Testing
Валідація(відповідність вимогам) та виявлення дефектів програмного продукту. Після виправлень невідповідностей відбувається повторна перевірка на новому білді.
На цьому етапі залучені не тільки тестери, але і девелопери беруть активну участь.

7) Deployment
Розгортання програмного забезпечення на енвайромент для замовника, де кінцеві користувачі можуть корисутватсь готовим функціоналом.

8) Operation and Maintenance
Вирішення проблем, з якими зіткнулись користувачі системи

-------
       |
 Agile |
       |
-------

Сімейство гнучких методологій(фреймворків) розробки програмного забезпечення, що базуються на ітеративній розробці.
Більшість методологій орієнтовані на мінімізацію ризиків, шляхом зведення розробки до коротких циклів - спрінт(ітерація).
Кожна ітераця складається з аналізу, планування, дизайну, девелопменту, тестування. Після завершення кожної ітерації готовий новий інкремент продукту, що можна показати замовнику та
отримати фідбек. Agile орієнтований на тісну кооперацію, реагування на зміни у вимогах, аніж притримування плану.
Agile не включає практик, а визначає цінності та принципи, якими керуються успішні команди.

Основні ідеї:

Особистості та їхні взаємодії важливіші, ніж процеси та інструменти;
Робоче програмне забезпечення важливіше, ніж повна документація;
Співпраця із замовником важливіша, ніж контрактні зобов'язання;
Реакція на зміни важливіша, ніж дотримання плану.
 
--------
        |
 Kanban |
        |
--------

Бережлива(lean - робота виконуєтсья on demand з меншими витратами, ніж при масовим виробництів без запиту) методологія розробки ПЗ, яка фокусується на just in time delivery функціональності та уникнені перевантаження членів команди.
Ціль Just-in-time manufacturing(Lean) мінімізувати втрати без жертвування продуктивністю. Kanban не ітеративний, а інкрементний, Continuous Delivery. Stop Starting, Start Finishing
Практики:

1) Візуалізація
Для візуалізації роботи та процесу, через який вона проходить, використовується Kanban board, що містить декілька стовпців, що репрезентують етап роботи, та картки, що уособлюють таску(work item). В залежності на якому етапі таска,
її переміщають на відповідний стовпець дошки. Це дозволяє легше сприйняти на якому етапі робота та ідентифікувати bottlenecks.

2) Обмеження роботи у процесі виконання
Переключення з одного завдання на інше призводить до втрати ефективності. На кожен статус виставляється максимальна кількість карток, що може міститись. Якщо місце заповнене, більше карток у цей статус перемістити не можна.
Це дозволяє зосередитись над завданнями з цього статусу і при потребі залучити більше людей.

3) Керування потоком
Керування робочим процесом, а не людьми, щоб вони були зайняті весь час. Сконцентрування на роботі та покращені процесу призведе до швидкого та плавного потоку(переміщення завдань через робочий процес).

4) Зрозумілий процес
Не можна покращувати процес розробки, якщо він незрозумілий. Тому він має бути зрозуміло описаний та донесений до людей.

5) Цикли фідбеку
Без фідбеку тяжко ідентифікувати проблеми та покращення, що не дає чітку картинку куди варто рухатись надалі.

6) Вдосконалюйтесь спільно, розвивайтесь експерементуючи
Ділитись новими ідеями, практиками, методами для подальшого розвитку.

-----------------
                 |
 Pair Programing |
                 |
-----------------

Практика розробки ПЗ, при якій код пишеться парою програмістів, які працюють за одним робочим місцем. Один пише код, другий програміст спостерігає за роботою, визначає можливі недоліки, помилки, радить.
Після певного часу програмісти міняютсья ролями. Це дозволяє обмінюватись досвідом, знанням про систему, покращує якість роботи. Недоліками можуть стати конфлікти, диктаторство, більш досвідчений програміст може займати більше часу за написанням і не ділитись відповідями, також вартість роботи збільшується через кількість робочих. 

-----
     |
 RAD |
     |
-----

Методологія, яка націлена швидку та якісну розробку ПЗ через тісну колаборацію з клієнтом. RAD фокусується на мінімізації етапу планування та ітеративній розробці прототипів. Для успіху необхідно мати клієнта, який готовий приділяти достаньо часу для оцінки прототипів та надавання фідбеку.

Етапи:
1) Planning
Визначення цілей та очікувань від проекту, бюджету, термінів, збір реквайрементів.

2) User design
Девелопери розробляють прототипи функціоналу системи та передають клієнтові на перевірку чи відповідає вимогам. Після певної кількості ітерації покращеня прототипу та валідації від клієнта будуть створені прототипи,
які повністю задовільняють клієнта.

3) Construction
На цьому етапі розроблені прототипи конвертуютсья у робочий продукт. Даний етап займає менше часу, ніж розробка з нуля, так як на цьмоу етапі вже є готові прототипи і бачення, як продукт має функціонувати.
Клієнт все ще може пропонувати та рекоментдувати покращення на цьому етапі.

4) Cutover
Фінальні налаштування, тестування, підготовка користувачів до використання.

-------
       |
 SCRUM |
       |
-------

Методологія управління проектами.

Існує перелік понять та ролей:
Product Backlog - пріоритезований список завадань(items, user stories), який треба виконати, щоб створити очікуваний продукт.
Product Owner - представляє зацікавлені сторони та є голосом клієнта. Ця людина добре знає бізнес та як він функціонує, відповідальна за створення items в беклогу та пояснення їх команді розробників.
Scrum Master - відповідає за те, щоб команда дотримувались SCRUM та поставлених цілей, вирішує організаційні проблеми.
Development team - команда розробників, що складаєтсья з 5-9 чоловік.

Процес у даній методології складається з послідовності sprint'ів, на виходію якого отримують інкремент програмного забезпечення, що показують зацікавленим особам та отримують фідбек про те, чи відповідає він очікуванням.
Це дає можливість швидко реагувати на зміни, що необхідно впровадити.
Sprint переважно триває від 1 до 4 тижнів, кількість може варіюватись від специфіки проекту, чим менший термін, тим швидше буде отримано фідбек по інкременту продукту та оцінено чи у правильному руслі рухається команда, чим більший,
тим менше затрати часу на активності, що йдуть на початку на кінці спранта(планування, ревю(демо), ретроспектива).
Для старту спрінта комнда влаштовує Sprint planing, на якому команда вибирає ту кількість роботи з Product Backlog, яку вона зможе виконати у рамках спрінта, та поміщаєтсья у Sprint Backlog.
Product Owner пояснює item команді і відбувається оцінка часу, за яку він виконаєтся. Після планування стартує спринт, у якому виконуються всі завдання з SprintBacklog. Також після старту спринту, нові зміни до вимог не додаються
до поточного, вимоги заморожені, та будуть враховані з наступним спрінтом. Кожного дня під час спрінта відбувається щоденна нарада(Daily), на якому кожен учасник відповідає на три питання: "Що зробив учора", "Що буду робити сьогодні",
"Які є блокери, що заважають виконати ціль". Дейлі починається точно у час, у тому ж місці, що і завжди, та триває 15 хв. Присутніми можуть бути всі, але говорять лише команда розробників, scrum master, product owner. 
Після завершення спринту команда влаштовує Sprint Review, на якому показується результат роботи, що виконала команда за спринт, інкремент продукту, зацікавленим особам. Отриманий фідбек враховується для планування наступного
спринта та розуміння чи у правильному напрямку рухається команда. Проводиться Grooming - процес приведення Product Backlog упорядок. Items додаютсья та видаляються, приоритезуються, переоцінюються, можуть уточнюватись деталі вимог,
причісування беклогу. Також проводиться Sprint Retrospective, на якій члени команди оцінюються спринт, що було зроблено добре, що погано та можна покращити у наступному.
Переваги:
1) Адаптивність до змін
2) Бачення клієнтом прогресу(інкремент ПЗ після кожного спринту)

Критика:
1) Значний час у розробці по SCRUM займає не розробка ПЗ, а саме введення Scrum процесу, мітинги і тд, що зменшує час розробки

-----
     |
 TDD |
     |
-----

Техніка розробки програмного забезпечення, у якій спочатку пишеться юніт-тест, а потім мінімально необхідний код функціональності, що повинен пройти даний тест.
Етапи:
1) Написання тесту
Реалізація кожної нової функції починається з написання тесту, що покриває дану функцію. Це дає чітке розуміння, що має бути розроблено до того, як імлементування фічі настає.
Після створення тесту він виконаєтсья неуспішно, так як функціонал ще не розроблено.

2) Написання коду
Далі пишеться мінімально необхідний код для того, щоб тест виконався успішно. Код на даному етапі не ідеальний і буде покращуватись під час рефакторинку.

3) Запуск всіх тестів
Перевіряються чи всі тести пройшли успішто та новий функціонал нічого не поламав(типу регресії)

4) Рефакторинг
Написаний код покращуєтсья, видаляється лишне.

Принципи: Keep it simple, stupid; You Ain't Gonna Need It. Написання модульних тестів форсить використання dependency inversion, клас має бути ізольований від інших, тому будь-які класи, з якими пов'язаний даний, stub'яться.
Замість конкретної реалізації, оголошено інтерфейс і у тестах передається stub. Дозволяє писати не тісно зв'язаний код, low coupling.

Переваги:
1) Прискорює розробку та дає більш чітке уявлення як функіонал має працювати до того як розробка почнеться
2) Покриття функціональності тестами, що мінімузує кількість баг(регресійні тести)

Недоліки:
1) Тяжко звикнути до такого підходу
2) Не все можна розробляти даним підходом(User interface and so on)
3) Додаткові витрати часу на написання тесут, що не завжди компенсуються пришвидшеним написання коду функціоналу.

-----------
           |
 Waterfall |
           |
-----------

Модель, в якій кожен етап SDLC відбувається після повного завершення попереднього та повернення до минулого етапу вимагає значних витрат. Використовуєтсья у проектах, де чітко зрозумілі, замоорожені реквайременти та коротка тривалість
проекту. У разі змін вимог це може зайняти значних ресурсів. Після встановлення фундаменту, побудови стін та даху, зміни до фундаменту дуже складні та затратні.
Planing => Requirements gathering & analisys => Design => Development => Testing => Deployment => Maintenance

Переваги:
1) Легко зрозуміле та просте у використані

Недоліки:
1) Відстуність гнучкості процесу
2) Необхідне хороше планування та аналіз вимог, щоб розроблене ПЗ співпало з очікуванням клієнта на кінцевому етапі
3) Підходить лиш для коротких проектів з чітко зрозумілими вимогами
4) Можлива невідповідність очікувань у клієнта, так як фідбек буде вже на останьому етапі. Відстуність фідбеку, чи у правильному руслі рухається команда.

-----------------------
                       |
Story Point Estimation |
                       |
-----------------------

Люди погані у естімейті годин, і у них краще виходить у відносній оцінці. Тяжко сказати скільки займе годин завершити таску, і легшше оцінити, що ця таска займе удвічі, утричі більшье часу, ніж інша.
This task will take twice as much work than that. При естімейті усіх айтемів береться найменший з колекції і все решта оцінюються відносно цього найменшого.

---------------
               |
 Bucket System |
               |
---------------

Техніка спільного швидкого оцінювання великої кількостів айтемів у малій або середній групі людей. Швидкість оцінювання великої кількості айтемів досягається за допомогою divide and conquer.
1) На столі ставлять buckets з цифрами 0,1,2,3,4,5,8,13,20,30,50,100,200.
2) З колекції айтемів дістається один, зачитується групі та кладеться у bucket посередині, наприклад у 8.
3) Після цього повторююься два круги, у яких дістають по одному айтему, зачитують, та спільно визначають оцінку відносно попередніх айтема-ів. Після досягнення консенсусу айтем кладеться у оцінений bucket
4) Якщо айтеми розмістились у одній з стороні, то треба перескейлити їх, щоб вони розміщались відносно по середині, щоб можна було оцінювати у обидві сторони дальше з більшою кількість значень
(Якщо айтеми знаходяться у відрах 1,2,3, неможливо оцінити менше, ніж за айтем, що у відрі 1)
5) Решта айтемів діляться порівну між усіх учасників і роздаються їм індивідуально. Кожен читає айтем і, не обговорюючи з кимось, кладе у відро, яке важає відповідає оцінці. Оцінуювання анонімне і проводитсья у тишині.
Якщо учасник не може оцінити айтем він може обміняти його у когось. Якщо хтось закінчив раніше, для пришвидшення процесу, їм можна віддати картки людей, що ще оцінили.
6) Після закінчення оцінювання всі переглядають айтеми, та якщо вважають, що якийсь не на свому місці, відбувається колективне переоцінювання до досягнення консенсусу.

----------------
                |
 Poker Planning |
                |
----------------

Техніка естімейчення для невеликої кількості айтемів.
1) Команда серед колекції айтемів вибирає найменший по затратам часу та ассайнить їй оцінку 2
2) Product Owner зачитує user story та відповідає на всі запитання, допоки команда не зрозуміє чітко вимогу
3) Кожен учасник вибирає карту з оцінкою айтема відносно визначеної на першому етапі двійки(числа Фібоначчі, card 4 means that item will take twice as more) та кладе лицем униз, що мінімізує вплив учасників один на одного
4) По черзі кожен показує карту, яку обрав
5) Учасники з найменшою та найбільшою цифрою пояснюють свій вибір, можливо хтось бачить додаткові складності, а хтось бачить як це можна зробити простіше
6) Відбувається переголосування, допоки всі не дійдуть консенсусу

------------
            |
 Dot Voting |
            |
------------

Використовується для прийняття рішень, пріоритизації, та може використовуватись у естімейтингу. Учасникам роздають обмежену кількість крапок, які вони прикріпляють до айтемів, що їм сподобались. На один айтем можна прикріпити будь-яку кількість доступних крапок.

-------------------------
                         |
 Relative Mass Valuation |
                         |
-------------------------

Техніка естімейчення для великої кількості айтемів відносно один одного.
Серед колекції айтемів вибирають відносно малу по затратах, середню та велику. Їх розкладають на столі, на початку меншу, у кінці найбільшу, по середині середню.
Команда проходиться по колекції айтемів та розміщують на стіл відносно попередній айтемів. Це дозволяє дуже швидко оцінити велику кількість айтемів.
Після ордерингу команда призначає оцінку 1 найменшому айтему. Після цього всім наступним айтемам, що не являються удвічі більше затратними по часу присвоюється 1. Всі наступні оцінки виставляютсья по такому ж патерну.

---------------
               |
 T-Shirt Sizes |
               |
---------------

Техніка естімечення без явної прив'язки до цифр, оцінка відбуваєтсья у розмірах футболок: XS(extra small), S, M, L, XL, XXL(double extra large), що дозволяє оцінювати більш абстрактно.
При необхідності оцінені айтеми потім можна перевести у цифри. Ця техніка добре підходить при початку відносного оцінювання(relative estimation vs absoulute estimation), після котрої переходять до story points.
Недоліком може виступити зменшення точності оцінки.