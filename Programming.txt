--------------------------
                          |
IEnumerable vs IQueryable |
                          |
--------------------------

IEnumerable дістає всі елементи і зберігає у пам'яті і фільтрує на клієнті, а IQueryable на сервері бази даних.
Deffered execution - отримання об'єктів відбуваєтсья, коли по колекції ітеруються, якщо ітерація не відбувається, запит до БД не здійснюється.
IEnumerable, навідміну від IQueryable, ітерується лише уперед.
IEnumerable & IQueryable не містять самі дані, а лиш запити, повторне виконання ітерування може виявити нові об'єкти

var enumerator = enumerable.GetEnumerator()
try
{
  while(enumerator.MoveNext())
  {
    enumerator.Current;
  }
}
finally
{
  enumerator.Dispose();
}

-----------------
                 |
 Microsoft Unity |
                 |
-----------------

IoC контейнер. Підтримує constructor, property, method injection and their ovverids.
IUnityContainer container = new UnityContainer();
container.RegisterType<ICar, BMW>();
container.RegisterType<ICar, Audi>("Luxury");
var bmw = container.Resolve<ICar>();
var audi = container.Resolve<ICar>("Luxury");

Case
{
  container.RegisterType<ICar, BMW>();
  container.RegisterType<ICar, Audi>();

  var audi = container.Resolve<ICar>(); //Using last registry
}

container.RegisterInstance<ICar>(audi); //Using object

Case
{
  If have multiple constructos, need to set InjectionConstructor attribute or run-time configuration: container.RegisterType<Driver>(new InjectionConstructor(container.Resolve<ICar>()));
  If property injection, need to use Dependency attribute or run-time configuration: container.RegisterType<Driver>(new InjectionProperty("Car", new BMW()));
  Also Dependency attribute have param name if there're several regestries like
  container.RegisterType<ICar, BMW>();
  container.RegisterType<ICar, Audi>("Luxury");

  [Dependency("Luxury")]
  public ICar Car {get;set;}

  If method injection , use InjectionMethod attribute or run-time configuration: container.RegisterType<Driver>(new InjectionMethod("UseCar", new Audi()));
}

Case
{
  For mupltiple custom parameters in constructor container.RegisterType<Driver>(new InjectionConstructor(new object[] { new Audi(), "Steve" }));
}

Overrides
{
  ParameterOverride: Used to override constructor parameters.
  PropertyOverride: Used to override the value of a specified property.
  DependencyOverride: Used to override the type of dependency and its value.

  var driver2 = container.Resolve<Driver>(new ParameterOverride("car"/*construcotr param name*/, new Ford()));
  var driver2 = container.Resolve<Driver>(new PropertyOverride("Car"/*property name*/, new Audi()));
  var driver2 = container.Resolve<Driver>(new DependencyOverride<ICar>(new Audi())
}

Time-life management
{
  TransientLifetimeManager - Creates a new object of the requested type every time you call the Resolve or ResolveAll method.

  ContainerControlledLifetimeManager - Creates a singleton object first time you call the Resolve or ResolveAll method and then returns the same object on subsequent Resolve or ResolveAll calls.

  HierarchicalLifetimeManager - Same as the ContainerControlledLifetimeManager, the only difference is that the child container can create its own singleton object.
  The parent and child containers do not share the same singleton object.

  PerResolveLifetimeManager - Similar to the TransientLifetimeManager, but it reuses the same object of registered type in the recursive object graph.

  PerThreadLifetimeManager - Creates a singleton object per thread. It returns different objects from the container on different threads.

  ExternallyControlledLifetimeManager - It maintains only a weak reference of the objects it creates when you call the Resolve or ResolveAll method.
  It does not maintain the lifetime of the strong objects it creates, and allows you or the garbage collector to control the lifetime of the objects. It enables you to create your own custom lifetime manager.

  .Net Core
  {
    Transient - об'єкт створюєтсья при кожному звертані
    Scoped - об'єкт створюється для кожного ріквесту. В межах ріквесту реюзається
    Singleton - об'єкт створюєтсья при першому виклику і на весь життєвий цикл застосунку

    Правило: об'єкт з коротшим циклом життя може залежити від об'єкта з таким ж або довшим життєвим циклом.
    Singleton - only singletone
    Scoped - scoped & singleton
    Transient - transient & scoped & singleton
    if Singleton depends on scoped, in next request scoped object will be disposed so it ends up with error
  }
}

----------
          |
 RabbitMQ |
          |
----------

Брокер повідомлень. Система, що реалізовує обмін повідомлень між компонентами програмної системи на основі протоколу AMSQP (Advanced Message Queuing Protocol).
Porducer(програма, що надсилає повідомлення у message queue) кладе у чергу повідомлення. Consumer(програма, що отримує повідомлення) прослуховує message queue.
Коли повідомлення приходить у чергу, викликається callback consumer'а, який обробляє повідомлення.

---------------
               |
 .Net Standart |
               |
---------------

Специфікація API, які повинні реалізовуватись у всіх платформах .Net(Framework, Core, Xamarin). Дозволяє створювати бібліотеки, які можна використовувати у всіх стеках .Net. Заміняє Portable Class Library.
Кожен зі стеків має нає свою базову бібліотеку класів. З введенням .Net Standart всі стеки будуть використовувати одні і ті ж API. Не містить API WebForms, WinForms, WPF, OS API like Registry, App domain. Platform agnostic

----------------
                |
 .NET Framework |
                |
----------------

Платформа для створення веб та десктоп застосунків на Windows.
Підтримувані фреймворки/технології: Windows Forms, WPF, ASP.NET, ASP.NET Web Forms, ASP.NET MVC, ASP.NET Web Api, SignalR, WCF. Supported languages: C#, F#, J#, C++, Visual Basic і тд.
Програма, що написана на .net сумісній мові, спочатку переводиться комілятором у (M)CIL(байт-код), у результаті чого створюється збірка. Після цього CIL виконується віруальною машиною(СLR). У CLR вбудований JIT-компілятор, який переводить
частину проміжного байт-коду(CIL), який виклакається, у машинний код процесора, що дозволяє не компілювати одразу всю прогарму, але лиш необхідну для виконування частину. Скомпільована частина зберігається у кеші ОП і при повторному
виклику не перекомпільовується, а дістає з кешу. CLR займається також безпекою, управлінняи пам'ятю та системних виключеннями.
Класи .Net Framework місяться у Framework Class Library(ASP.NET's, Desktop, WCF, BCL). Ядром FCL являєтсья Basic Class Library(BCL), містить примітивні, системні типи. MSCorLib

CIL - проміжний байт код, який виконує CLR та перетворюєтсья JIT-компілятором у машинний код. Ця проміжна мова служить для того, щоб програми, які написані на різних .net сумісних мовах, компілювались у одну, яка б виконувалась.
При компіляції програми створюється модуль DLL чи EXE, вміст якого називається збірка(assembly, contains IL & metadata). Окрім, модуль містить метадані - опис типів, що використовуються у модулі(інфа про клас, інтерфейси, методи,
властивості, події). Також, окрім опису типів, міститься інформація про саму збірку. Ця частина називається маніфест. Маніфест містить інфу про версію збірки, обмеження безпеки, список зовнішніх необхідних збірок.

-----
     |
 CLR |
     |
-----

Середовище виконання застосунків написаних на .net сумісних мовах. Віртуальна машина(набір служб), що виконує CIL код, займаєтсья управління пам'яттю(виділення пам'яті і розміщення об'єктів, управління посиланнями, вивільнення об'єктів з пам'яті),
потоками, завантаженням збірок, безпекою виконання(безпека типів, пам'яті, один об"єкт не може зайняти пам'ять іншого), обробкою виключних ситуацій. Код, який керується CLR називається керованим, відповідно,
який не керуєтсья - некерований. Некеровані ресурси CLR вивільняти не може, тому таким майже займатись сам програміст. Це об'єкти операційної та файлової систем, WinAPI, драйверів, відеокарти, мережі. Ці ресурси ніяк не пов'язані з .Net,
тому CLR не може їх менеджити.
Всі об'єкти і типи .Net являєтсья керованими. Але частина з них являєтсья оболонкою над некерованими ресурсами. Клас Form містить посилання на хендлер вікна з некерованого WinApi. FileStream являєтсья керованим, але містить хендлер
файлу, який посилається на некерований файл з WinApi. Зазвичай об'єкти, що містять некеровані ресурси реалізують інтерфейс IDisposable. Некерований код компілюється одразу в машинні інструкцію(без проміжного етапу з CIL), керований за
допомогою компайлера мови, якою було написано, у CIL, а CIL вже Jitter'ом у програмні інструкції, що займає додаткову динамічну пам'ять та час.
Містить JIT-компілятор. Якщо JIT-компілятор не забезпечує необхідної продуктивності, можна скористатись NGen.exe утиліткою, яка компілює весь CIL код у машинні інструкції та зберігає у файл.

Виконуваний файл містить:
Заголовок - інформація про тип процесора, на якому виконуватиметься програма. PE32 - 32 і 64 - біт ОС, PE32+ - лише 64-біт ОС
Заголовок CLR - флаги, версія CLR, точка входу Main
Метадані - типи, що існують у збірці та зовнішні типи, на які посилаються, їх члени 
IL код

При запуску спочатку аналізується заголовок і визначається який процес запустити, 32 чи 64 розрядний. Завантажується версія MSCorEE.dll відповідно до розрядності. Після цього викликається метод у MSCorEE, який ініціалізує CLR.
CLR підвантажує збірку, всі типи і виконує IL код. При звернені до функції JIT-компілятор компілює код у машинній інстуркції, які виконуютсья процесором, та зберігає у кеші ОП для повторно використання без потребності у повторному
компілювані. Перший виклик відпрацьовує повільніше через компіляцію, але наступні вже будуть мати прекомпільовані інструкції. Якщо буде запущена ще одна програма, то весь процес буде повторено і JIT знову буде перекомпільовувати.
Хоч це одна і та ж програма, просто два різні процеси, вони все таки ізольовані один від одного, тому не шарять прекомпільовані інстуркції. Якщо перший повільний запуск не підходить, то можна використати утилітку NGen.exe, яка одразу
космпілює IL в машинні інструкції і зберігає у файл. JIT-компайлер може оптимізовувати код, так як він бачить все і може використовувати інструкції конкретного машинного коду, що призначені для конкретного процесора, видалити деякі
ділянки коду, що ніколи не виконаються.

Під час встановлювання .Net Framework файли збірок Microsoft встановлюютсья у двох екземплярах. Один набір у каталог з CLR, другий у GAC. Файли в каталозі CLR полегшують білд збірки, а копії у GAC призначені для завантаження ПІД ЧАС
ВИКОНУВАННЯ. Збірки в каталозі CLR містять лише матадані(таблиці з типами, методами і тд) без IL коду, так як на етапі компляції він непотрібен.

-------------------
                   |
 Garbage Collector |
                   |
-------------------

Об'єкти зберігаються у двох місцях: у стеку та кучі(Small Object Heap & Large Object Heap).
Value type objects можуть зберігатись у стеку або у кучі, в залежності де вони оголошені. Якщо value type оголошено у методі, то його значення зберігається у стеку, якщо як член класу, то він знаходитиметься у кучі.
При створені Reference type object у стеку зберігається не самий об'єкт, як у value type, а вказівник на ділянку у керований кучі, де власне і збережений об'єкт.
Кожний метод має виділену ділянку пам'яті у стеку, який вивільняється по завершеню методу. У випадку з value type у стеку, разом з очисткою стеку після завершення методу видалиться і об'єкт. З reference type ситуація інша.
Так як в стеку збережено лише вказівник на об'єкт, а не сам об'єкт, буде видалено лише вказівник, об'єкт продовжить існувати у кучі. Для вирішення такого роду проблем у .Net існує Garbage Colletor.
Garbage Collector - механізм CLR автоматичного управління пам'яттю. Основне його призначення вивільняти пам'ять з об'єктів, що більше не використовуютсья у програмі. Якщо на об'єкт у програмі немає вказівника, тоді GC ставить його у
чергу на фіналізацію. GC не викликається одразу як вказівник у стеку був очищений, він спрацьовує тоді коли CLR повідомить про брак пам'яті і ініціалізує збірку сміття. GC не проходиться по всіх об'єктах у кучі, це було б не раціонально.
Об'єкти у кучі поділяються на три покоління: 0, 1, 2. До 0 покоління належать об'єкти, які ще не проходили збірку сміття, до 1 - які вже один раз, до 2 - більше одного разу. Спочатку GC проходиться по новостворених об'єктах,
що уособлюють 0 покоління. GC очищує пам'ять всіх об'єктів, на яких немає вказівника. Всі об'єкти, що не були видалені, переходять у наступне покоління. Якщо після очищення пам'яті недостатньо, GC проходиться по 1 поколінню,
не включаючи тих, що тільки-но були переведені у це покоління. Так само, всі об'єкти, що пережили збірку сміття, переходять у 2 покоління. Також у 2 покоління попадають всі Large Object при створені. Якщо все ще бракує пам'яті,
GC очищає 2 покоління. Ідея в тому, що об'єкти, які вже довго знаходяться у кучі, імовірно, що і продовжують використовуватись, а новостворені мають більший шанс, що вже не використовуються. Тому прохід починається з 0 покоління.
У пам'яті покоління має вказівник на початкову адресу і всі об'єкти, що знаходяться у блоку від початку цього покоління і до початку наступного належать до нього.
Об'єкт у кучі зберігається блоком і у ній виникають місця, прогалини, які занадто малі для збереження об'єкту. Хоч пам'яті і виглядає, що достатньо, деколи об'єкт не можна помістити у кучу. Для цього після збірки сміття,
GC проводить дефрагментацію Small Object Heap. Так відбувається позбування від цих пробілів. Цей процес займає певний час, але дає переваги у продуктивності, так як при наступних виділення пам'яті CLR під об'єкт буде відбуватись значно
швидше. Після дефрагментації необхідно обновити посилання на нові ділянки пам'яті. Це стосується лише Small Object Heap.
Large Object Heap, у яку попадаютсья об'єкти більші за 85 000 байт(поріч може бути змінено), не дефрагментується, так як цей процес через тривалість переміщення великих об'єктів не дає необхідної продуктивності, на відміну від Small Object Heap.
Об'єкти в LOH належать одразу до 2 покоління, не варто створювати великі короткоживучі об'єкти.

Виклик GC:
1) Сповіщення від CLR про нестачу місця
2) Пам'ять, виділення під об'єкти у 0 поколіні, перевищує поріг. Якщо пам'яті очищено недостатньо або перше чи друге поколіня перейшло поріг, починається підчистка тих поколінь.
Пороги поколінь визначаютсья GC і можуть налаштовуватись під час виконання програми(аналізує та адаптується).
3) Виклик GC.Collect. При передачі true аргументу збірка сміття відбудеться одразу, при false GC підбере час, коли виконати буде раціональніше.
4) Вигрузка домену застосунку. Відбувається повна чистка всіх поколінь.
5) Завершення роботи CLR.

Етапи GC:
1) Зупинення всіх потоків, щоб під час збірки сміття стан програми не змінювався, так як це може вилитись у критичні помилки з пам'яттю
1) Маркування. CLR(GC) перебирає всі об'єкти покоління(проходиться по стекам потоків і маркає з кучі об'єкти), просетуючи біт індексу блоку синхронізації 0, і за допомогою алгоритму відслідковування посилань сеттає тим об'єктам, на яких є посилання, в поле індексу блоку синхронізації біт.
Об'єкти з 0 бітом можуть видалятись. Зустрівши вже марканутий об'єкт, СLR ігнорує його, щоб уникнути циклічності посилань.
2) Зжимання. Всі об'єкти, що використовуються, переміщують на початок, щоб вони займали суміжний блок пам'яті. Посилання на об'єкти замінюються на новий вказівник(з вказівника віднімають кількість байт, на які було переміщено об'єкт)
3) Після зжимання NextObjPtr вказує на блок пам'яті після останнього немусорного об'єкту. Починаючи з цього блоку буде виділятись пам'ять під новий об'єкт.

Режими роботи:
1) робоча станція - оптимізований для мінімізації зупинки потоків застосунку. Припускає, що на машині запущено і інші програми, тому мінімізує викоримстання CPU.
2) сервер - припускає, що на машині не запущені сторонні програми, тому всі ресурси можна кидати на збір сміття. У цьому режимі керована куча розбирається на декілька розділів - по одному на процесор.
Паралельна очистка - перформанс.

По замовчуванню використовується режим робочої станції, запуск серверного застосунку(ASP.NET) може вимагати запуск у режимі сервера.
Якщо серверний застосунок стартує на однопроцесорній машині, то завжди працює у режимі сервера.

Підрежими:
1) паралельний - GC має фоновий потік, який виконує маркування під час роботи застосунку
2) непаралельний

В Object класі міститься protected virtual метод Finalize. Якщо похідний клас переоприділяє цей метод за допомогою конструкції ~[Назва класу], то перед вивільненням пам'яті з під об'єкта викликається метод фіналізації.
Так як метод може звертатись до полів класу, пам'ять об'єкту не може бути вивільнено одразу, що продовжує життя об'єкту і об'єктів, на яких він посилається і також помічені як "сміття". Тому об'єкт повинен пережити збір сміття і переходить у наступне покоління. 
Через продовжуання життя об'єту та потенційно іншим об'єктам, не рекомендується використовувати методи фіналізації для об'єктів з полями reference type.
Також слід врахувати, що програмість не може знати коли саме буде викликано метод фіналізації. Також CLR не дає гаранті в якому порядку будуть викликатись методи Finalize, можливо, що метод буде звератись до об'єкту, який також переоприділяє фіналізатор і вже був вивільний до того.
З фіналізатора можна звератись до полів value type, а такоє до reference type, що не реалізуються фіналізатор. Якщо у методі фіналізації відбувається неперехоплене виклчення, то такий процес завершується.
Черед ряд цих недоліків варто щоб керований ресурс, що містить некерований, наслідувався від SafeHander.
Так як SafeHandler наслідується від CriticalFinalizerObject, це дозволяє CLR викликати фіналізатори цих об'єктів останніми, тобто звичайний об'єкт у методі фіналізації може з впевненітю звератись до об'єкта, що наслідується від SafeHandle.

При створені об'єкта з методом фіналізації за допомогою оператора new перед викликом конструктора у список фіналізації(GC finalization list) поміщається вказівник на об'єкт. Ця внутрнішня структура вказує на об'єкти, при вивільння яких потрібно викликати фіналізатор.
При очистці об'єкта GC дивиться чи немає посилання на нього у списку фіналізації. Якщо є, то запис вилучається та добавляє у кінець черги на фіналізацію(freachable queue). В CLR є особливий високопріорітетний(для запобігання проблем з синхронізацією) потік для виклику методів фіналізації.
При відсутності елементів у черзі цей потік не діє, як тільки появляються він почергово викликає методи фіналізації. Поки на об'єкти є посилання у списку чи черзі вони перестаютсья бути "мусором".
Після виклику методу фіналізації при наступному проході ПОКОЛІННЯ, ДО ЯКОГО належить об'єкт, GC маркає його як сміття і тільки тоді GC вивільняє пам'єть з під об'єкта.
ЦЕ ОЗНАЧАЄ, ЩО ДЛЯ ОБ'ЄКТА З ФІНАЛІЗАТОРОМ ТРЕБА ЯК МІНІМУМ ДВА ВІДПРАЦЮВАННЯ GC. Може бути і більше двох разів, так як об'єкт переміщається на покоління дальше і необхідно очиста саме цього покоління.
Тому фіналізатори провокують довге життя об'єктів, які реально вже не потрібні програмі.

Бувають ситуації коли малий managed resource(4-8 байтів) містить великий unmanaged(16 mb), для GC все виглядатиме впорядку, хоча насправді викорстовується велика кількість пам'яті.
Для вирішення цієї проблеми можна у конструкторі класу викликати метод GC.AddMemoryPressure(_size)(у фіналізаторі GC.RemoveMemoryPressure(_size)).

Для кожного домену застосунку CLR підтриму таблицю GC-дескрипторів (GC handle table), за допомогою якого застосунок відстежує час життя об'єктів або дозволяє керувати вручну.
В момент створення домену таблиця пуста. Кожний елемент таблиці складається з вказівника на об'єкт в кучі і флага, яки задає спосіб моніторинга чи контролю об'єкта.
Застосунок добавляє елементи в таблицю або видаляє за допомогою структури System.Runtime.InteropServices.GCHandle.
Для контроля або моніторинга викликаєтсья статичний метод GCHandle.Alloc(), в який передається вказівник(IntPtr) на об'єкт і GCHandleType(моніторинг/контроль).
GCHandleType enum:
1) Weak - моніторинг часу життя об'єкту. Флаг дозволяє дізнатись чи GC вважає об'єктом, що більше недоступний застосунку. Невідомо чи фіналізатор вже викликався, тому об'єкт ще може бути у пам'яті.
2) WeakTrackRessurection - як Weak, але фіналізатор вже виконано, тобто пам'ять вже вивільнено.
3) Normal(default) - контроль часу життя об'єкту. Флаг вказує, що об'єкт не повинен бути очищений, навіть якщо на нього більше нема посилань. Може бути зжатий(переміщений).
4) Pinned - як Normal, але неможна переміщати. 

При виклику Allocate здійснюється пошук у таблиці елементу, що посилаєтсья на об'єкт, переданий у аргументі, просетує значення флагу та повертається екземпляр GCHandle - полегшений value type, який у своєму єдиному екземплярному полі IntPtr, який є вказівником на індекс в таблиці.
Щоб вивільнити цей елемент в таблці потрібно викликати метод Free та передати йому екземпляр GCHandle.

Через високі вимоги до безпеки при фіксації чи зберегані об'єкта в пам'яті працювати з типом GCHandle не просто, в простір імен System був включений допоміжний клас WeakReference<T>
Це обгортка GCHandle: конструктор цього класу викликає метод Alloc класу GCHandle, його властивість TryGetTarget читає властивість Target класу GCHandle, метод SetTarget задає властивість Target класу GCHandle, а метод Finalize — метод Free класу GCHandle.
Для роботи з класом WeakReference коду не потрібно спеціального дозволу, так як цей клас підтримує тільки слабкі посилання. GCHandleType підтримується тільки Weak or WeakTrackRessurection/

~MyClass
{
    DoSomeJob();
}

equals to

{
    try
    {
         DoSomeJob();
    }
    finally
    {
         base.Finalize();
    }
}

-------------
             |
 IDisposable |
             |
-------------

Патерн для звільнення некерованих ресурсів. Лише для керованих ресурсів неварто реалізовувати цей патерн, так як GC сам впорається. Керованими ресурсами також ввжається такі, що реалізовують IDisposable(оболонка над некерованими).
Клас реалізовує інтерфейс IDisposable, який містить лише один метод void Disposable(). Даний метод викликає protected virtual Dispose(bool disposing) метод, який приймає булевий параметр disposing, який означає чи звільняти керовані
ресури. Так як клієнт, що використовуватиме об'єкт, може не викликати Dispose метод, необхідно перестрахуватись і звільнити некеровані ресурси. Для цього необхідно створити метод фіналізації у класі, який викликаєтсья при знищені об'єкта GC'ом.
void Disposable метод викликає внутрішнью реалізацію, де власне і звільняються ресурси, з параметром true, що, окрім некерований, вивільнить і керовані ресурси. Так як всі ресурси звільнено, необхідно превентнути виклик методу фіналізації.
Для цього викликається GC.SuppresFinalize. Метод фіналізації у свою чергу викликає внутрішній метод Dispose з параметром false, що означає, що керовані ресурси не будуть звільнятись, так як порядок звільнення керованих ресурсів невідомий,
можливо вони вже були звільнені GC до того.

Important

It is possible for a base class to only reference managed objects, and implement the dispose pattern. In these cases, a finalizer is unnecessary. A finalizer is only required if you directly reference unmanaged resources.
Фіналізатор звільнює пам'ять тільки unmanaged resources, якщо таких немає, то і оголошувати фіналізатор не варто, так як він продовжєу життя об'єкта.

class Form : IDisposable
{
  private bool _disposed;
  
  ~Form()
  {
    Dispose(false);
  }

  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing)
  {
    if (_disposed)
    {
      return;
    }

    if (disposing)
    {
      // Disposing managed resources
      //form.Dispose();
    }

    // Disposing unmanaged resources

    _disposed = true;
  }
}

class InheritedForm : Form
{
  private bool _disposed;

  ~InheritedForm()
  {
    Dispose(false);
  }

  protected ovveride void Dispose(bool disposing)
  {
    if (_disposed)
    {
      return;
    }

    if (disposing)
    {
      // Disposing managed resources
    }

    // Disposing unmanaged resources

    _disposed = true;

    base.Dispose(disposing);
  }
}

-----
     |
 CTS |
     |
-----

Специфікація, яка описує оголошення, використання, управління типами в CLR. Набір правил, типу об'єкти абстрактного класу неможливо створити, видимість і доступ членів типу, правила наслідування(клас може наслідуватись лише від одного
класу та реалізовувати безліч інтерфейсів), робота віртуальних методів, всі типи наслідуютсья від System.Object і тд.
Любий тип містить нуль або більше членів.
Члени:
Поле - зміна класу, стан об'єкта.
Константи - поля класу, які встановлюютсья при компіляції і не можуть бути змінені.
Властивість - об'єднання стану та поведінки, використовуєтсья для інкапсуляції поля.
Метод - функція, поведінка класу.
Події - повідомлення про виникнення певної ситуації.
Індексатори - індексування об'єкту подібно масиву.
Конструктори - методи, що викликаютсья при створені об'єкта. Використовуютсья для ініціалізації членів.
Метод фіналізації (не деструктор, так як він детермінований, у CLR це неможливо забезпечити) - метод, який викликаєтсья при вивільнені об'єкта з пам'яті. Явно викликати його неможливо і викликаєтсья автоматично garbage collector.
Після того як на об'єкт ніхто не посилаєтсья у певний час GC вивільнить об'єкт, викликавши метод фіналізації, також по завершеню програми всі GC вивільняє всі об'єкти
Перегружені оператори
Вкладені типи

Модифікатори доступу:
private - член(вкладені типи також члени) доступний лише в межах класу або структури.
protected - член доступний у межах того ж класу або структури чи у похідному.
internal - член доступний будь-звідки у межах збірки.
public - член доступний як у власній збірці так і в іншій.
protected internal - доступ до члену може здійснюватись у його збірці або у похідному типі з іншої збірки
private protected - доступ до члену може здійснюватись лише з поточної збірки у віднаслідуваних типах

Клас може бути лише public, internal, якщо вкладений, то і private.

-----
     |
 CLS |
     |
-----

Специфікація, притримування якої гарантує взаємодію типів, що на писані на різних .Net сумісних мовах. Правила застосовуються лише до частин типу, що предназначені для взаємодії за межами збірки, тобто до public, protected classes and members.
Якщо створений тип призначений для роботи на іншій мові, то він має притримуватись тих можливостей, що є у даній мові. [assembly: CLSCompliant(true)] заставляє компайлер перівіряти на CLS-сумістність.
Деяків мови не являютсья регістро чутливитими, тому у типі не має бути два методи з одинаковою назвою, але різним кейсом. Також інші мови можуть не мати деякі типи даних.

-----------
           |
 Типізація |
           |
-----------

Слабка/сильна типізація
Сильна типізація не дозволяє об'єднувати у виразі різні типи і не виконує неявне перетворення. Слабка проводить неявне перетворення, навіть з втратою точності.

Статична/динамічна
Статична - тип змінної встановлюєтсья на етапі компліяції. Динамічна - під час виконання.

Явна/неявна
У явно-типізоованій мові тип зміних потрібно задавати явно, у неявних ця робота покладаєтсья на компілятор.

С# вміщає статичну, динамічну(dynamic), сильну, явну і неявну(var) типізацію

----
    |
 C# |
    |
----

Статичні класи, змінні, методи зберігаютсья у High Frequency Heap.

Узагальнення - механізм, який наближує C# до динамічних мов, зберігаючи при цьому безпеку типів/
Переваги:
1) Value type не упаковуються та розпаковуються, що значно імпруває перформенс(менше об'єктів у кучі, менше викликів GC). Example: ArrayList.Add(object) & List<int>.Add(int)
2) Безпека типів
3) Простий та зрозумілий код
Недоліки:
Розростяння коду(code explosion) - JIT генерує машинний код для кожного value типу, що незначно, але впливає на перформенс.
Для всіх reference types буде використовуватись один і той же код, так як команди для роботи з посилання одинакові для всіх видів reference type, оперування відбуваєтсья з вказівником,
а він лиш може відрізнятись розрядністю(32 || 64-біт). Для кожного value type буде генеритись різний код.

Коваріантність та контраваріантність підтримуєтсья з С# 4.0 у делегатах та інтерфейсах лише для reference types.
Інваріантність - параметр-тип не може змінюватись.
Контраваріантність (in) - параментр-тип може змінюватись від класа до похідного класу у вхідній позиції(параметр методу).
Коваріантність (out) - аргумент-тип може змнюватись до одного з його базових класів у вихідній позиції(тип повернення з методу).

Делегати - обгортка для методу зворотнього виклику(callback). Являється класом, що наслідується від MulticastDelegate => Delegate => Object
При оголошені делегату створюється клас з таким ще модифікатором доступу, як і у делеагата. Клас містить конструктор(приймає object - посилання на екземпляр, якщо метод не статичний, та посилання власне на метод), метод Invoke,
який має синатуру оголошеного делегата, метод BeginInvoke & EndInvoke. Клас також містить три приватних поля: _target(Object) - null, якщо метод, що передається у делегат, статичний або посилання на екземпляр, метод, 
якого використовується._methodPtr - посилання на метод, _invocatioList - ланцюг делегатів.
Екземпляр делегату може або містити метод зворотнього виклику або ланцюг делегатів, але не обидва варіанти одночасно.
Якщо екземпляру делегату присвоюєсять метод, то _target буде містити null або екземпляр, метод якого використовується, _methodPtr - посилання на метод, _invocationList - null;
Якщо два делегати об'єднуються за допомогою Delegate.Combite або +=(що транслюється у Delegate.Combine), то _targer - null, _methodPtr - null, _invocationList = new Delate [] {delegate1, delegate2}
-+ трансформується у Delegate.Remove. Delegate.Remove видаляє з _invocationList делегат, який містить необхідний метод, але лише перший, який знайде, якщо було підписано два таких, один залишиться у списку.
При кожному виклику Delegate.Combite/Remove створюється новий екзмепляр делегату.
Виклик екземпляру делегату як функції перетворюється у виклик методу Invoke екземпляру делегату.
MyDel del = new MyDel(ReturnMeMyVALUE);
int five = del(5); --del.Invoke(5)

public int Invoke(int value)
{
    int returnValue;
    Delegate[] chain = _invocationList as Delegate[];
    if(chain != null)
    {
         foreach(var del in chain)
         {
              returnValue = del.Invoke(value);
         }
    }else
    {
        returnValue = _methodPtr.Invoke(value);
    }

    return returnValue;
}

Повертається лише значення виконане останнім делегатом, якщо якийсь з методів навертається, виклики наступних зупиняються. Для отримання списку делеагів є метод GetInvocationList.
Якщо _invocationList null, то GetInvocationList поверне у масиві лише один делегат, який власне і являється тим самим екземпляром делегата.

Щоб не плодити свої делегати, краще скористатись 17 версіями void Action, який приймає від 0 до 16 аргументіів, або Func, який дозволяє повертати занчення і також приймає від 0 до 16 арг.
Свої треба оголошувати, якщо у хочеш передавати аргумент з ref, out, params.

Вже що написано за допомогою event, можна переписати з використанням просто делегатів, так event лише фрапер над делегатами. Але event, як і властивість для поля, необхідна для інкапсуляції, щоб не похерити дані.
Наприклад, один клієнт підписався на делегат, другий занулив цей делегат і створив новий зі зсвоїм хендлером, перший клієнт вже не отримає сповіщення. З подіями можна уникнути цього. Занулит не вийде, дозволяєьбся лише += -=(add remove event methonds).

Лямбда функція підставляється у те місце, де очікується делегат. Створюється приватний анонімний метод, який буде статичний, якщо немає доступу до екземплярних членів типу, з атрибутом CompilerGeneratedAttribute.
Також створюється делегат, який огорне анонімну функцію.

internal sealed class AClass
{
  public static void CallbackWithoutNewingADelegateObject()
  {
       ThreadPool.QueueUserWorkItem(obj => Console.WriteLine(obj ), 5);
  }
} 

internal sealed class AClass
{  
  // Это закрытое поле создано для кэширования делегата
  // Преимущество: CallbackWithoutNewingADelegateObject не будет создавать новый объект при каждом вызове
  // Недостатки: кэшированные объекты недоступны для сборщика мусора
  [CompilerGenerated]  private static WaitCallback <>9__CachedAnonymousMethodDelegate1;

  public static void CallbackWithoutNewingADelegateObject()
  {
       if (<>9__CachedAnonymousMethodDelegate1 == null)
       {
           // При первом вызове делегат создается и кэшируется
           <>9__CachedAnonymousMethodDelegate1 = new WaitCallback(<CallbackWithoutNewingADelegateObject>b__0);
       }
       ThreadPool.QueueUserWorkItem(<>9__CachedAnonymousMethodDelegate1, 5);
  }

  [CompilerGenerated]
  private static void <CallbackWithoutNewingADelegateObject>b__0(Object obj)
  {
       Console.WriteLine(obj);
  }
}

Якщо у тілі лямбди використовуються локальні зміни, то створюється спеціальний клас з полями для локазльних змін і анонімна функція створюється у тому ж спец класі.

Try/finally генерується автоматично при використані:
1) using - в finally викликається IDispose
2) foreach - в finally викликається IDispose IEnumerator
3) lock - в finally змінається лок
4) при оголошені методу фіналізації в блоку finally викликається base.Finalize
Environment.FailTest заставляє процес завершитись і finally з Finalize не виконуються. Викликати варто тільки коли система у плачевному стані і будь-які дії тільки можуть пошіршити стан.

При виконанні оператору new, CLR:
1) підраховує кілкьість байтів, які необіхдні для розміщення екземпляру типу
2) добавляє до порахованої кількості ще байти для системних полів(індекс блоку синхронізації та вказівник на об'єкт-тип). 32-біт - + 8 байт, 64 - 16 байт
3) перевіряє чи у кучі достатньо місця для розміщення об'єкту. Якщо достатньо, то виділяє пам'ять з вказівника NextObjPtr. NextObjPtr вказує на вільний блок пам'яті після розміщеного об'єкту.
4) new повертає посилання на об'єкт
3a/4a) якщо об'єкт має метод фіналізації, то поміщає у список фіналізації посилання на об'єкт, виклик конструктора.


Domain - ізольований контейнер для набору збірок. При запуску процесу створюється дефолтний AppDomain, далі можна створювати інші доменти.
Властивості:
1) Об'єкти, створені одним доменом, недоступні іншому. Доступ можна отримати лише через marshaling-by-reference/value. Створені такі об'єктами являються представниками, а не справжніми об'єктами, проксями.
2) CLR не підтримує вигрузку окремих збірок, лише по завершеню програми. Зате можна вигрузити домен зі всіма його збірками, не вплинувши на інші домени.
3) Кожен домен можна індивідуально налаштовувати, захищати, встановлювати дозволи, щоб операції одного домену не зашкодили іншому.

Вигрузка доменту:
1) CLR стопає абсолютно всі потоки
2) Всі потоки, що виконуться у домені, який треба вигрузити, генерують виключення ThreadAbortException. Виконуються finally блоки. Незахенделні ThreadAbortException CLR проковтує і не зупиняє процес.
3) Флагаються всі об'єкти-представники, що прийшли з вигружаємого домену. При наступному звернені до них буде згенеровано виключення AppDomainUnloadedException
4) СLR ініціалізує примусову повну збірку сміття з виконaнням методів фіналізації
5) СLR відновлює роботу всіх потоків.

Компілятор виконує оптимізації, що можуть змінити порядок зчитування чи запису, яке при багатопотоковому виконані спричинить неочікувані наслідки.
class A
{
    private int x;
    private int y;
    
    void Thread1()
    {
        y = 5;
        x = 1;
    }

    void Thread2()
    {
       if(x == 1)
       {
           Console.WriteLine(y);
       }
    }
}

Компілятор може поміняти порядок присвоєння у методі Thread1 так, що при виконанні паралельний потоком меод Thread2 x вже буде дорівнюватиме 1, а виведене значення y = 0; Також значення може бути закешоване і не перевірятись чи змінилось.
Щоб уникнути цієї ситуації, варто у Thread1 ОСТАННЄ присвоєння записати за допомогою Volatile.Write(ref x, 1), а ПЕРШЕ зчитуванння за допомогою Volatile.Read(ref x).
Volatile.Write в кінці забезпечить, що всі присвоєння, що написані попереду, будуть здійснені до виклику Write. А Read напочатку забезпечить, що решта зчитувань будуть здійснені тільки після виконання Read.
volatile не дозволяє компілятору здійснювати оптимізації. Для полегшення можна операції Volatile.Read/Write замінити, оголосивши поле x volatile, але воно все ще має присвоюватись ОСТАННІМ і зчитуватись ПЕРШИМ.

Наприклад
Interlocked представляє атомарні операції для змінних, які досутпні декільком потокам.

-----------------------------------
                                   |
Multi-threading-tasking-processing |
                                   |
-----------------------------------

Process - об'єкт операційної системи, контейнер системних ресурсів для виконання програми. Процес містить виконавчий файл, віртуальний адресний простір, дескриптори операційної системи
(дескриптори файлів, handles), системні ресурси(CPU, memory...)
Віртуальний адресний простір процесу відділяє код та дані від іншого процесу, так що вони не можуть нашкодити один одному. Також можна виділити більше оперативної пам'яті, ніж насправді є.
Віруальні адреси конвертуються у фізичні за допомогою Memory Management Unit.
Thread - послідовність інструкцій. Вони розділються ресурси процесу і зміна контексту між threads одного процесу швидша, ніж між різними процесами.
Thread не ізольовані між собою, навдміну від процесів.
Колись 16 біт ос містила лише один потік і якщо з ним щось ставалось, то приходилось чуть не ребутати комп. Введення потоку на кожен процес значно полегшило життя і закращений потік у процесі не впливає на решту потоків у іншиї процесах.
Одноядерний CPU може виконувати лише один потік одночасно, при використані технології HyperThreading, таке ядро може мати декілька логічних процесорів і виконувати відповідну
кількість потоків. 2 Physical CPU cores + HyperThreading - 4 logical CPU cores(processors)
Multithreading - здатність CPU підтримувати декілька потоків виконання одночасно, періодично змінюючи контекст виконання між потоками. CPU => Process => Thread1, Thread2....ThreadsN
Multitasking - здатність CPU виконувати декілька процесів(tasks) одночасно, періодично змінюючи контекст виконання між процесами. CPU => Process1(Thread1), Process(Thread1, Thread2)
Multiprocessing - здатність комп'ютерної системи підтримувати більше одного процесора і розподіляти процеси між цими процесорами. Компухтер => CPU1(Process1, Process2), CPU2(Process1)
Multithreading про виконання декількох потоків у процесі, multitasking - виконння декілької процесів на одному CPU, multiprocessing - здатність підтримувати декілька процесорів і розподіляти роботу по них.

OS sets up a timer which interrupts the system at a fixed interval. A single interval is known as a time slice. Everytime this interrupt occurs, the OS runs the scheduling routine,
which picks the next thread that is due to be executed. The context of the core is then switched from the currently running thread to the new thread, and execution continues.

-----
     |
 TPL |
     |
-----

Потік складаєьться з
1) Об'єкт ядра потоку(thread kernel object) - структура даних, що описує потік. Містить контекст потоку(блок пам'яті з набором регістрів процесору).
2) Блок оточення потоку - містить заголовок ланцюга обрибки виключень.
3) Стек користувацького режиму(user-mode stack). Застосовується для збереження аргументів і локальних змін у методі. Також містить адрес звідки почне потік виконання, коли поточний метод поверне управління. По замовчуванню 1 Мб.
4) Стек режима ядра
5) Повідомлення про створення та завершення потоків

Потоки бувають активними(foreground) і фоновими(background), при завершення всіх активних потоків виконується завершення фонових потоків та завершення процесу. Фонові для некритичних задач, які можна відновити після перезапуску застосунку.
Вакто уникати активних потоків, які використовуються не по призначеню, так як це може призупинити завершення процесу, хоча роботу, яку він виконує не являєтсья критичною, щоб дочікуватись виконання цього потоку.

Потоки мають пріорітети. Рендж пріоритетів від 1-31. Процесорний час отримує потік з вищим пріорітетом,
навіть під час виконання потік може бути перервати посеред такту і віддане управління більш пріоритетному потоку. Тому не варто створювати потоки з пріоритетом 30-31, так як вони можуть не дати час виконання іншим потокамю.
Потоки з 0 пріорітетом не можна створити і використовуються windows'ом для одбнулення вільних сторінків і виконується тільки коли немає інших потоків.
Цифри від 1 до 31 не дають програмістам чіткого розуміння, який для чого використати, тому Windows має прослойку над рівнями пріоритетів.
Пріорітети процесу: Idle, BelowNormal, Normal(default), Above Normal, High, Realtime.
Пріорітети потоку: Idle, Lowest, BelowNormal, Normal(default), Above Normal, Highest, Time-Critical.
Комбінація процесу і потоку даєть ті числа від 1 до 31. Під драйвери пристроїв зарезервовано 17, 18, 19, 20, 21, 27, 28, 29, 30, їх не можна присвоїти застосункам.
Process with normal priority and normal thread priority have priority number 8.

Потоки можна створювати за допомогою класу Thread. сигнатура делегатів, що приймає конструктор, дозволяє void method() & void method(object). Створений потік по дефолту являється активним, його можна змінити у фоновий за допомогою
проперті IsBackground.
Створення потоку, переключення контексту, все це являється затратними процесами.

На .Net краще користуватись класом ThreadPool(метод QueueUserWorkItem), у чергу(спочатку перевіряється локальна черга(Last-In-First-Out, стеком мало б називатись) потоку, якщо нема, то черга(Last-In-First-Out, стеком мало б називатись)
іншого потоку, а потім глобальна черга)якого можна помістити методи, які необхідно виконати. ThreadPool якщо не зможе опрацювати всі методи за допомогою одного потоку, створить ще потоки(фонові).
Потоки, що завершили виконання та яким не дали на виконання, повератються у пул та очікують нових завдань. Так як створення потоку затратна по пам'яті та продуктивності операція, використання вже готовий потоків з пулу значно пришвидкує роботу. 
Через деякий час простою потік самознищується. Пул потоків створюється для кожного завантаженого екземпляру CLR.
При створені потоку, у нього копіюється контекст виконання з покому, що створює. Це затратна процедура, якщо потік не буде використовувати цю інформацію. У цьому випадку краще виключити копіювання за допомогою ExecutionContext.SuppressFlow().

Присутня функція відміни операції. Якщо метод виконується занадто довго(можна задати час після якого кенцилити дію) або необхідно відмінити його виконання, можна скористатись класом CancellationTokenSource.
Вн містить readonly властивість IsCancellationRequested, readonly властивість Token, метод Cancel.
Token являєтсья об'єктом структури CancellationToken та містить статичну пропертю None, що повертає CancellationToken, який дозволяє відмінити відміну операції, readonly властивість IsCancellationRequested,
метод ThrowIfCancellationReuqest, СanBeCanceled та метод Register, що дозволяє зареєструвати коллбеки, що викликаютсья при відміні операції.
Можна залінкувати два токена в один об'єкт CancellationTokenSource. При відміні одного з токенів, об'єкт CancellationTokenSource стає також відміненим.

var cts = new CancellationTokenSource();
cts.Token.Register(() => Console.WriteLine("Canceled 1"));
cts.Cancel();

Недоліком ThreadPool являється те, що не можна отримати повертаюче значення та дізнатись чи завершилось виконання методу. Якщо необхідні ці властивості, тоді краще cкористатись класом Task, але в свою чергу він займає багато пам'яті і
не варто використовувати його, якщо можна обійтись ThreadPool. Клас Task у основі використовує ThreadPool.
Клас Task дозволяє зареєструвати метод, що виконається після основного за допомогою ContinueWith. Можна вказати, щоб виконувався тільки, якщо попередній виконано успішно або було неопрацьоване виключення або скасовано.
Таsk представляє собою асинхронну операцію.
Await - застосовуєтсья до асинхронної операції(Task) та одразу повертає значення, якщо операція закінчена, або дозволяє потоку повернутись у пул та виконувати іншу роботу, щоб не блокувати його, допоки операція не виконається.
Після виконання операції який потік підбере управління та продовжить роботу, аwait знову поверне результат виконання. Не можна використовувати await у синхронній функції, в lock, в catch, finally, unsafe

Асинхронна функція перетворюєтсья у кінцевий автомат(конечний автомат, state machine). Функція маркається атримубом [AsyncStateMachine(typeof(StateMachine/*назва згенерованох структури, в якій містится код*/)
і всередині нього відбувається ініціалізація об'єкту StateMachine та запуск його білдера. Після цього повертається таска з публічного поля білдер об'єкта StateMachine. Cама структура реалізує інтерфейс IAsyncStateMachine,
який має метод MoveNext(). Цей метод і містить інструкції з асинхроної функції, він  викликаєтсья декілька разів, але з кожним викликом продовжує з іншої частини методу, це досягається операторами switch та goto та збереженим станом у
полях структури.

З асинхроної функції можна дістати об'єкт стурктури TaskAwaiter, який має властивість IsComplete, метод GetResult, методи OnComplete/UnsafeOnComplete для підпіски на виконання функції. При використані await на функції, використовується метод GetAwaiter,
що повертає об'єкт стурктури TaskAwaiter.

Різниця між синхроність, асинхроність та паралельність
Представте три працівника офісу, одному з них треба віднести решті різні папери, щоб вони там щось написали, та повернутись назад за стіл, щоб поставити печатку.
Синхронно: працівник відносить папери одному колезі, чекає поки той напише необхідне, і повертається на місце ставе печатку. Потім відносить інші папери другому колезі, попросту простоює в очікувані, повертається та ставить печатку.
Асинхронно: працівник відносить папери одному колезі, так як очікування займе непонятно скільки часу, щоб не простоювати без роботи, працівник йде і відносить інші папери дургому колезі, потім повертається за результатом і ставить печатки.
Паралельно синхронно: для цього у нас повинно існувати два працівника, які паралельно відносять ці папери колегам та дочікуються результату, блокуючи свою роботу
Паралельно асинхронно: два працівники відносять папери колегам, та повертаютсья в пул, щоб отримати нову роботу.

Приготовление завтрака представляет собой хороший пример асинхронной непараллельной работы. Один пользователь (или поток) может обрабатывать все эти задачи.
Продолжая аналогию с завтраком, один человек может приготовить завтрак асинхронно путем запуска очередной задачи до завершения предыдущей. Готовка продолжается вне зависимости от того, следит ли за ней кто-либо.
Как только вы начали греть сковороду для яичницы, можно заняться обжаркой бекона. Когда бекон будет жариться, можно поместить хлеб в тостер.
Для параллельного алгоритма потребовалось бы несколько поваров (или потоков). Один готовит яйца, один — бекон и т. д. Каждый из них будет заниматься только одной задачей. Каждый повар (или поток) будет заблокирован синхронным ожиданием
готовности бекона или тостов.

-------------
             |
 ASP.NET MVC |
             |
-------------

У файлі Global.asax представлено клас застосунку, який наслідується від HttpApplication та зазвичай називається MvcApplication.
При першому запуску та КОЖНОМУ запиті створюється інстанс цього класу, але Application_Start & Application_End методи викликаються лише при першому запуску застосунку і при створені об'єкту для запиту вони не викликаються.
Впродовж життєвого циклу запиту викликаються наступні події:
1) BeginRequest: событие возникает, когда приложение получает новый запрос
2) AuthenticateRequest/PostAuthenticateRequest: событие AuthenticateRequest возникает при идентификации (аутентификации) пользователя, сделавшего запрос. А после его обработки срабатывает событие PostAuthenticateRequest
3) AuthorizeRequest/PostAuthorizeRequest: AuthorizeRequest возникает при авторизации запроса, после этого срабатывает событие PostAuthorizeRequest
4) ResolveRequestCache/PostResolveRequestCache: событие ResolveRequestCache возникает, когда приложение обращается к кэшу для получения данных. При получении данных их кэша затем срабатывает событие PostResolveRequestCache
5) MapRequestHandler/PostMapRequestHandler: MapRequestHandler срабатывает при определении обработчика запроса. После выбора обработчика срабатывает событие PostMapRequestHandler
6) AquireRequestState/PostAquireRequestState: событие AquireRequestState возникает при получении данных состояния, связанных с запросом (например, данные сессии). И после него срабатывает событие PostAquireRequestState
7) PreRequestHandlerExecute/PostRequestHandlerExecute: событие PreRequestHandlerExecute происходит непосредственно перед началом работы обработчика запроса, а событие PostRequestHandlerExecute - после его работы
8) ReleaseRequestState/PostReleaseRequestState: событие ReleaseRequestState возникает, когда приложению больше не требуются данные, ассоциированные с запросом. И после освобождения этих данных просиходит событие PostReleaseRequestState
9) UpdateRequestCache: возникает при обновлении данных в кэше
10) LogRequest/PostLogRequest: событие LogRequest происходит непосредственно перед каждым логгированием, а PostLogRequest - после завершения всех обработчиков событий
11) EndRequest: возникает при завершении обработки запроса, когда данные для ответа уже готовы к отправке клиенту
12) PreSendRequestHeaders: возникает перед отправкой HTTP-заголовков браузеру клиента
13) PreSendRequestContent: возникает после отправки заголовков, но перед отправкой основного содержимого ответа

Для додавання хендлеру цих подій достатньо створити метод з префіксом Application_ + назва події або підписатись у конструкторі BeginRequest += (src, args) => ...

Життєвий цикл застосунку:
Прийшов ріквест
1) Створенням екземпляру класу MvcApplication
2) Якщо перший запит для застосунку, то викликається Application_Start
3) BeginRequest => AuthenticateRequest => PostAuthenticateRequest => AuthorizeRequest => PostAuthorizeRequest => ResolveRequestCache => PostResolveRequestCache => MapRequestHandler
4) Вибирається обробник запиту, IHttpHandler
5) PostMapRequestHandler => AquireRequestState => PostAquireRequestState => PreRequestHandlerExecute
6) Виконання IHttpHandler
7) PostRequestHandlerExecute => ReleaseRequestState => PostReleaseRequestState => UpdateRequestCache => LogRequest => PostLogRequest => EndRequest => PreSendRequestHeaders => PreSendRequestContent
8) Відправка відповіді
10) Колись застосунок буде зупинено і буде викликано Application_End
Application life cycle - 1-10 step, Request life cycle - 1,

Фреймворк дозволяє створити спеціальні класи, які мають можливість керувати обробкою запиту, вони називаються модулі. Ці модулі ініціалізуються після створення екземпляру MvcApplication.
Модуль реалізовує інтерфейс IHttpModule, який містить методи Dispose та Init, що приймає екземпляр HttpApplication. Через цей об'єкт можна підписуватись на події. Для реєстрації модуля треба вказати його у Web.config.
public class MyModule : IHttpModule
{
    public void Init(HttpApplication app)
    {
        app.BeginRequest += HandleBeginRequest;
        app.EndRequest += HandleEndRequest;
    }
    
    public void Dispose {}
}

<system.webServer>
  <modules>
    <add name="MyModule" type="LifeCycleApp.Modules.MyModule"/>
  </modules>
</system.webServer>

Фреймворк має ряд вбудованих модулів:
DefaultAuthentication - встановлення значення властивості User в HttpContext
AnonymousIdentification - ідентифікація запитів, навіть коли користувач не аутентифікований, для анонімних запитів
FileAuthorization - Windwos Authentication
OutputCache - кешування відповідей
Session - зв'язування даних сесії з запитом

IHttpHandler використовуються для генерації відповіді на запит. При обробці запиту може бути задіяно безліч модулів, але тільки один http хендлер співставляється для запиту.

Фільтри
Деколи необхідно здійснити певні дії, перевірки перш, ніж виконувати action метод або після його виконання. Для цього є фільтри, які реалізовану у вигляді атрибутів.
Базові типи фільтрів:
IAuthenticationFilter - Немає реалізацій - визначає чи аутентифікований юзер. Виконується раніше будь-якого іншого фільтра і action метода
IAuthorizationFilder - AuthorizeAttribute - визачає чи має  юезр доступдо реурсу виконуєтсья після IAuthenticationFilter і до  будь-якого іншого фільтра і action метода
IActionFilter - ActionFilterAttribute - фільтр, що застосовується до дій, може виконуватись як до, так і після виконання action методу.
IResultFilter - ActionFilterAttribute - фільтр, що застосовується до результату дій, може виконуватись як до, так і після виконання action методу.
IExceptionFilter - HandleErrorAttribute - фільтр для оброки виключень, що були викинуті з action метода або результату action.

IAuthenticationFilter
1) void OnAuthentication(AuthenticationContext filterContext)
2) void OnAuthenticationChallenge(AuthenticationChallengeContext filterContext)

IAuthorizationFilder
1) void OnAuthorization(AuthorizationContext filterContext)

IExceptionFilter 
1) void OnException(ExceptionContext filterContext)
2) ExceptionHandled property, false if not handled error

IActionFilter
1) void OnActionExecuting(ActionExecutingContext filterContext) - before action method call
2) void OnActionExecuted(ActionExecutedContext filterContext) - after

public class MyActionAttribute : FilterAttribute, IActionFilter
{
    public void OnActionExecuted(ActionExecutedContext filterContext)
    {
        filterContext.HttpContext.Response.Write("Действие выполнено");
    }
 
    public void OnActionExecuting(ActionExecutingContext filterContext)
    {
        if (filterContext.HttpContext.Request.Browser.Browser=="Opera")
        {
            filterContext.Result = new HttpNotFoundResult();
        }
    }
}

IResultFilter
1) void OnResultExecuting(ResultExecutingContext filterContext) - before action method returns result
2) void OnResultExecuted(ResultExecutedContext filterContext) - after action method returns result

Реалізація IActionFiler & IResultFilter
public abstract class ActionFilterAttribute : FilterAttribute, IActionFilter, IResultFilter
{
    public virtual void OnActionExecuting(ActionExecutingContext filterContext){}
    public virtual void OnActionExecuted(ActionExecutedContext filterContext){}
    public virtual void OnResultExecuting(ResultExecutingContext filterContext) {}
    public virtual void OnResultExecuted(ResultExecutedContext filterContext) {}
}

Якщо фільтр має використовуватись на всіх action методах всіх контролерів, тоді варто зареєструвати його глобально у FilterConfig
public class FilterConfig
{
    public static void RegisterGlobalFilters(GlobalFilterCollection filters)
    {
        filters.Add(new HandleErrorAttribute());
             
        filters.Add(new MyExceptionAttribute());
        filters.Add(new MyResultAttribute());
    }
}

Похідні фільтри:
1) AllowAnonomous,
2) [HandleError(ExceptionType = typeof(System.IndexOutOfRangeException), View = "ExceptionFound")]
3) RequireHttps
4) OutputCache
5) ValidateAntiforgeryToken

-----------------
                 |
 ASP.NET Web Api |
                 |
-----------------



---------
         |
 SignalR |
         |
---------

Бібліотека, що спрощує додавання функцій в реальному часі для застосунку. Фукцікції у реальному часі - це можливість серверу надсилати контент підключеним клієнтам миттєво, як тільки з'явиться,
а не очікувати запит від клієнта, щоб надіслати відповідь. Також бібліотека дозволяє викликати скріптові функції на стороні клієнта(server-to-client RPC, call js functions on client from server-side),
так і виклик серверних функцій з клієнта. SignalR включає зручний API для керування з'єднаннями(події про підключення, відключення).
Для обміну даними між клієнтом та сервером використовується один з наступних транспортів, в залежності чи підтримується сторонами:
1) WebSocket - двосторонній протокол обміну повдомленнями, що дозволяє серверу надсилати дані, не дочікуючись ріквест від клієнта, у одному TCP конекшині.
2) Server-sent events - односторонній обмін(лише з сервера)
3) Forever frames
4) Long polling - клієнт відправляє запит, а сервер тримає запит на очікувані, допоки не появиться дані, після цього відправляє дані. Після цього клієнт одразу створює наступний запит

Моделі:
1) Persistent Connection - доступ до низькорівневому протоколу
2) Hub - взаємодія на більш високому рівні, представляє layer над Persistent Connection та дозволяє клієнту і сервкру викликати методи один одного.

-------
       |
 xUnit |
       |
-------

[Fake] on test method. That's all. Simple as fck
Assert class to compare expected and actual results

--------------------
                    |
 FluentAssertations |
                    |
--------------------

Бібліотека extention методів для перевірки очікуваного результату в unit tests. Підтримує низку unit test frameworks: xUnit, NUnit, MSTest and others.
Замість використання класу Assert, над результатом викликається метод розширення Should(), який повертає ObjectAssertion instance, над яким і здійснюютсья перевірки. Для складання декількох перевірок можна використати проперю And.

string actual = "ABCDEFGHI";
actual.Should().StartWith("AB").And.EndWith("HI").And.Contain("EF").And.HaveLength(9);

Action action = () => recipe.AddIngredient("Milk", 100, Unit.Spoon);
action.Should().Throw<RuleViolationException>().WithMessage("*change the unit of an existing ingredient*")

-----
     |
 Moq |
     |
-----

Фреймворк, який довзоляє створвати моки та стаби залежностей модуля, що тестується. Дозволяє мокати інтерфейси, віртуальні методи. Не можна статичні та невірутальні методи.
Mock підтримує дві моделі перевірки поведінки: strict & loose. По дефолту - loose, яка перевіряє, що цей метод повинен викликати, а чи виконаються чи не виконаються решта неважливо.
При strict, якщо якийсь не виконаєтсья або виконається, який не було вказано в Setup, тест не пройде. Для перевірки поведінки використовується mock.Verify().

ILoggerDependency loggerDependency =
    Mock.Of<ILoggerDependency>(d => d.GetCurrentDirectory() == "D:\\Temp");
var currentDirectory = loggerDependency.GetCurrentDirectory();
 
Assert.That(currentDirectory, Is.EqualTo("D:\\Temp"));

                            Stub
----------------------------------------------------------------------------

Mock<ILoggerDependency> stub = new Mock<ILoggerDependency>();
 
stub.Setup(ld => ld.GetDirectoryByLoggerName(It.IsAny<string>()))
    .Returns<string>(name => "C:\\" + name);
 
string loggerName = "SomeLogger";
ILoggerDependency logger = stub.Object;
string directory = logger.GetDirectoryByLoggerName(loggerName);
 
Assert.That(directory, Is.EqualTo("C:\\" + loggerName));

----------------------------------------------------------------------------

ILoggerDependency logger =
    Mock.Of<ILoggerDependency>(
        d => d.GetCurrentDirectory() == "D:\\Temp" &&
                d.DefaultLogger == "DefaultLogger" &&
                d.GetDirectoryByLoggerName(It.IsAny<string>()) == "C:\\Temp");

                            Mock
-------------------------------------------------------------------------------

var mock = new Mock<ILogWriter>();
var logger = new Logger(mock.Object);
 
logger.WriteLine("Hello, logger!");
 
// Проверяем, что вызвался метод Write нашего мока с любым аргументом
mock.Verify(lw => lw.Write(It.IsAny<string>()));

-------------------------
                         |
 Google Protocol Buffers |
                         |
-------------------------

Механізм серіалізації даних на заміну XML, менший, швидший, простіший. Для оголошення структури даних, які будуть серіалізуватись, у .proto файлі описується messages.

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

Кожен філд позначений унікальним числом, та має тип даних та назву.

required: message повинен мати точно одне таке поле.
optional: message може не мати дане поле або мати одне.
repeated: поле може повторюватись безліч раз, включно і не бути присутнім

На основі цього файлу у застосунку protocol buffer compiler генерує класи, які можна з легкість серіалізувати та десерфіалізувати у ці структури.

Після додавання нових філдів у структуру старі бінарники будуть ігнорувати нові філди, що підтримує backwards-compatibility, при парсинку не буде помилки.

person {
  name: "John Doe"
  email: "jdoe@example.com"
}

Не підходить для Javascript, краще використовувати JSON.

-------------
             |
 Katana/OWIN |
             |
-------------

Owin - специфікація, що оприділяє взаємодію між веб-застосунком та веб-сервером. Впроваджує абстракцію веб-серверу та дозволяє будувати свій конвеєр обробки запитів. Це дозволяє запускати застосунок на любому сервері, що реалізовує OWIN.
Розробник може підключати ті модулі, які йому необхідні, як наприклад модуль аутентифікації, статичних файлів, і не буде перегружений лишньою функціональність як на IIS.
Всі веб-застосунки тісно зав'язані від бібліотеки System.Web, що представляє взаємодію з IIS. Це означає, що застосунок може бути захощений тільки на IIS і при перенесені на інший тип веб-сервер прийдеться змінювати код,
також System.Web являється частиною .Net Framework, який обновляєтсья дуже рідко, що являється мінусом, коли хочеш використовувати нові вкусняшки.
Основа - це делегат AppFunc = Func<IDictionary<string, object>, Task>. IDictionary містить середовище сервера, запит і відповідь.

Katana - реалізація специфікації OWIN, яка доволяє заспускати застосунок на IIS та self-host. Також представляє допоміжні типи та методи, які спрощують конфігурування модулів OWIN. Наприклад, замість IDictionary об'єкти
OwinRequest & OwinResponse

Pipleline - шлях через який проходить ріквест і респонс до і від застоунку. Веб-сервер після отримання ріквесту, розміщує його інформацію у Dictionary та передає у middleware pipeline. Middleware на основі інформації з словника виконує
певну логіку та передає цей словний іншій middleware, яка у свою чергу виконує свою логіку, і так допоки ріквест не дойде до застосунку. Після отримання ріквесту застосунком, він дивиться по якому шляху звертався клієнт та виконує певну
функціональність, записує response headers та потім response body. Як тільки вперше у response body буде щось записано, server відправляє клієнту response message з response headers, що були на даний момент. З цього моменту ніхто не може
змінювати response headers, але допоки connection відкритий можна дописувати у response body. Після того, як застосунок закінчить обробку запиту, словник проходить через middleware pipeline у зворотньому порядку.
Middleware може перервати обробкузапиту так, що він не дойде до застосунку, і відправити respone власноруч, наприклад autentication middleware не побачила session cookie і відправила на сторінку логінення.

----------------
                |
Microsoft Prism |
                |
----------------

Фрейморк для побудування loose coupled, testable XAML applicaitons in WPF. XAML?!?!? WPF?!?!? Датвидули))0)

-------
       |
 Nancy |
       |
-------

Фреймворк для побудови веб-застосунків на .Net. Може використовуватись як middleware у owin pipeline або selfhost(console application + nancy).
Оголошуєтсья клас, що віднаслідуєтсья від NancyModule, у конструкторі по http verb і шляху визначається делегат, що буде хендлити запит. Модуль лоудиться при кожному ріквесті.
Get["/hello"] = parameters => "Hello wold"

------------
            |
 Quartz.NET |
            |
------------

Фрейморк для планування завдань(Task Scheduler). Створюєтсья джоба, що реалізовує інтрфейс IJob. У Execute методі описується логіка, що повина виконуватись на виконані джоби.

public class EmailScheduler
    {
        public static async void Start()
        {
            IScheduler scheduler = await StdSchedulerFactory.GetDefaultScheduler();
            await scheduler.Start();
 
            IJobDetail job = JobBuilder.Create<EmailSender>().Build();
 
            ITrigger trigger = TriggerBuilder.Create()  // создаем триггер
                .WithIdentity("trigger1", "group1")     // идентифицируем триггер с именем и группой
                .StartNow()                            // запуск сразу после начала выполнения
                .WithSimpleSchedule(x => x            // настраиваем выполнение действия
                    .WithIntervalInMinutes(1)          // через 1 минуту
                    .RepeatForever())                   // бесконечное повторение
                .Build();                               // создаем триггер
 
            await scheduler.ScheduleJob(job, trigger);        // начинаем выполнение работы
        }
    }

--------
        |
 Rx.NET |
        |
--------

Бібліотека для асинхроних застосунків, що дозволяє отримувати сповіщення про зміну даних у колекції. Являєтсья реалізацією інтерфейсів IObservable<T>/IObserver<T>, що лишає необхідті робити це самому. Колекція може бути подій,
веб-запитів, stream файла, системних нотифікацій.
Використовуючи IEnumerable застосунок працює синхроно(except IAsyncEnumerable in C# 8.0), моваєтсья по енумератору і дістає поточне значення(Pull-based).
Якщо дата сорсом даних являєтсья база даних, то IEnumerable буде фрізити потік, допоки дані не прийдуть, IObservable дозволяє уникнути цього і здійснювати дії, допоки external call виконується.
IObservable дозволяє підписатися на зміну стану колекції.
IObserver інтерфейс представляє спостерігача, який реєструє інтерес через підписку.
Для підписки на зміни до колекції викликається метод Subscibe on collection та передається instance of IObserver. Результатом виклику являється клас підписки, яку можна задіспоузити, тим самим відписавшись від сповіщень.
Rx має метод розишення для підписки(Subscribe), що дозволяє не створювати інстанс класу, що реалізовує IObserver, а передавати делегати на такі події OnNext, OnError, OnCompleted. Колекція підтримує ті ж LINQ-запити, що і IEnumerable.

IObservable<int> source = Observable.Range(1, 5); //creates an observable sequence of 5 integers, starting from 1
IDisposable subscription = source.Subscribe(
                            x => Console.WriteLine("OnNext: {0}", x), //prints out the value being pushed
                            ex => Console.WriteLine("OnError: {0}", ex.Message),
                            () => Console.WriteLine("OnCompleted"));

---------
         |
 Swagger |
         |
---------

Специфікація для опису API. За допомогою інструментів можуть генерувати код, документацію і тести за файлом інтерфейсу.
На стороні API action method описується атрибутами Swagger, що дають інфу про response code, ноатку, тип, що повертає.
Swagger UI - візуалізація та взаємодія з API. 

------
      |
 XAML |
      |
------

Декларативна мова розмітки

-----
     |
 UWP |
     |
-----

Уніфікована платворма для стоврення та запуску додатків у Windows 10.
