-------
       |
 Array |
       |
-------

Примітивна структура даних фіксованого розміру, колекція елементів певного типу, що зберігається послідовно у пам'яті, доступ до елементів здійснюється за допомогою індексу. Бувають одновимірні та багатовимірні масиви, також існуються масиви масивів, у яких обов'язково тільки вказувати кількість масивів, що буде зберігатись, а їх довжина може бути різною. Також масиви розрізняються по індексації, zero-based, one-based, n-based.
Елементи масиву у пам'яті зберігаються послідовно, так що до кожного елемента одновимірного масиву можна достукатись по формулі base address + index * data type size.
Масиви часто використовуються для побудування більш складних структур, таких як: heap, queue, stack and so on.
Доступ до елементу: O(1)
Вставка у кінець: O(1)
Вставка/видалення: O(N) треба перемістити всі елементи після на позицію вперед або назад, не факт що є місце, може потрібно буде resize

---------------------------
                           |
 Disjoint Set / Union-Find |
                           |
---------------------------

Структура даних для створення та об'єднання множин, а також перевірити чи два елементи знаходяться у одній множині. Всі ці операції виконуються за майже константний час.
Кожна множина множина має представника(representitive), це один із елементів множини. При перевірці на знаходеження двох елементів у одні множині достатньо перевірити чи обидва елементи мають одинакового представника.
Операції:
1) MakeSet(x) - cтворює множину з елемента х. Представник - x.
2) Union(x, y) - об'єднує множину x з у. Представник - x.
3) Find(x, y) - перевіряє чи x та у належать до однієї множини

-------
       |
 Graph |
       |
-------

Нелінійна структура даних, яка складається з вершин та ребер, що об'єднують ці вершини. Одна вершина може мати множину ребер та допускає зациклення та самозациклення(ребро на саму себе).
Представити граф можна за допомого одновимірно масиву вершин, та двовимірного масиву ребер(ребро між A - 0, B - 1 = edges[0, 1] - Adjacency Matrix). Графи бувається неорієнтовані(двонаправлені) та орієнтовані(однонаправлені), зважені та незважені.

Граф може бути представлений як:
1) Adjacency Matrix - квадратична матриця, у якій кожна веришна має рядок та стовпчик, якщо дві вершини мають спіільне ребро, то у матриці проставляється значення 1, якщо ні - 0.
Adjacency complexity of O(G) = |V|, Terrible space complexity of Θ(G) = |V|²
Реалізація:
Двовимірний масив

    A B C D
  A 0 0 0 1
  B 0 0 0 1
  C 0 0 0 1
  D 1 1 1 0

G = [[0,0,0,1],
     [0,0,0,1],
     [0,0,0,1],
     [1,1,1,0]]

2) Adjacency List - Список списків вершин, я кими суміжна кожна вершина. Створюєтсья пустий список на кожну з вершин, індекс списку відповідає номеру вершини.
Реалізація:
1) масив Linked List'ів. Кожен 
2) масив масивів

E = [[],[],[],[]]  ---> E = [[1,2,4],[0],[0],[4],[0,3]] == E = {0:[1,2,4], 
     								1:[0], 
     								2:[0], 
     								3:[4], 
     								4:[0,3]}
Space complexity of Θ(G) = |V|+ 2|E|
Great adjacency complexity. For a given vertex v, O(G) is equal to d(v) the Degree of v.
Degree - кількість ребер до вершини.

Операції:                  Adj List                 Adj Matrix
Додати вершину                O(1)                  O(|V|^{2})
Додати ребло                  O(1)                     O(1)
Видалити вершину             O(|E|)                 O(|V|^{2})
Видалити ребро               O(|V|)                    O(1)
Чи дві вершини з'єднані      O(|V|)                    O(1)
                           Slow to remove          Slow to add or remove vertices,
			vertices and edges,        because matrix must be resized/copied
                        because it needs
                        to find all
                        vertices or edges


-----------
           |
 Hashtable |
           |
-----------

Структура даних, що релізовує асоціативний масив, дозволяє зберігати пари ключ-значення та здійснювати над ними операції пошуку, вставлення та видалення за константний час, якщо не відбулась колізія. Доступ до значення відбувається через ключ, він зкормлюється хеш-функції, завдання якої по ключу повернути індекс bucket'а, в якому зберігається значення.
У хеш таблицях існує поняття load factor - це значення, як дорівнює кількості елементів у таблиці до загальної кількості buckets. При зростані цього значення погіршується швидкодія хештаблиці, так я частіше стаються колізії. Колізія - це ситуація, коли по двом і більше ключам було отримано одинаковий індекс. При досягнені границі load factor створюється удвічі більша внутрішня структура buckets та значення з старої переносяться у нову з перехешованими індексами, це призводить до того, що константна операція буде виконуватись за O(N) часу. Це доволі затратна операція і деякі системи не можуть собі позволити перестати відповідати через цей довготривалий ресайз. Тому є декілька підходів: у одному переносятся всі значення одразу, при другому лише частина при операціях до хештаблиці(нові значення додаються одразу в нову структуру, при пошуку старих певна кількість значень переноситься у нову, допоки не буде перенесено всі значення і пам'ять під стару структуру можна буде звільнити). Також внутрішня структура зменшується, якщо кількість елеменів перейшли нижній поріг.
Правильний підбір хеш-функції також сильно впливає на швидкодію, так як стається менше колізій.
Методи розв'язування колізій:
1) Метод ланцюжків. Кожна комірка масиву є вказівником на зв'язний список пар ключ/значення, що відповідають одному індексу з хеш-функції. При виникнені колізії нова пара додається у кінець списку, а попередня містить посилання на неї. Операція пошуку тепер виконується за час проходу до потрібного значення по зв'язному списку.
Найгірша ситуація може статись, коли хеш-функція повертає на всі ключі однин ідекс і всі пари зберігаються у одній комірці. Тоді доступ стає O(N)
2) Відкрита адресація. Відкрита адресація означає, що індекс з хеш-функції не відповідає точному місцю збереження ключ/значення.
Масив buckets містить саму пару/ключ значення. Якщо виникає колізія, відбувається пошук від індексу далі, допоки не буде знайдено пустий bucket, куди і запишеться пара. При пошуку починаючи з індекса хеш-функції кожен bucket порівнюється чи ключі співпадають. Якщо знайдено було пустий bucket, то такої пари не існує.
Видалення при такому методі дещо складніше. Для кожного bucket додається булевий флаг чи він видалений. При видалені він сетається 1 і при вставці туди можна перезаписати, пошук при такому флазі каже, що пари не існує(Не шарю чому просто не занулювати)

Існуєть хеш-таблиці з прямою адресацією, де колізії не відбуваються, так як всі ключі зарання відомі і можливо побудувати досконалу хеш-функцію.

Хештаблиця не підходить для малої кількості елементів, хоч і досутп відбувається за константний час, але виконання хорошої хеш-функції може перевищувати прохід по всіх елементах у списку.
          Avarage       Worst
Search     O(1)         O(n)
Insert     O(1)         O(n)
Delete     O(1)         O(n)

C# Hashtable vs Dictionary(preffered)
1) Dictionary generic so for value types it's faster, no need in boxing/unboxing
2) If key not presented Hashtable returns null, Dictionary - error
3) Dictionary maintains the order of stored values, Hashtable - no

-------------
             |
 Linked List |
             |
-------------

Лінійна структура даних, колекція елементів, які зв'язані між собою вказівниками. Елементами у даній колекції є ноди, які складають з даних та вказівників. Обмежений тільки пам'яттю застосунку і доти може динамічно розростатись. Linked List містить посилання на першу ноду, яка називається head.
Існує декілька видів Linked Lists:
1) Замкнутий однозв'язний. Нода місить посилання на наступну. Остання нода у вказівнику на наступну містить null. Довзоляє проходитись лише у одну сторону
2) Замкнутий двозв'язний. Окрім вказівника на наступну ноду, містить вказівник на попередню. Head нода у вказівнику на попередну містить null. Довзоляє проходитись у обидві сторони
3) Циклічний однозв'язний. Остання нода у вказівнику на наступну ноду містить посилання на head.
4) Циклічний двозв'язний. Окрім того, що остання нода у вказівнику на наступну ноду містить посилання на head, Head у вказівнику на попередню ноду містить посилання на останню ноду.

Переваги:
Відсутність фіксованого розміру
Швидве додавання/видалення. У масиві треба змістити всі елементи після, у linked list поміняти вказівник на наступну ноду

Недоліки:
1) Довільний доступ як з індексами у масиві неможливий, треба проходитись
2) Додаткова пам'ять виділяється на вказівник
3) Не cache friendly, так як ділятнка у пам'яті непослідовна

Використовується для побудови стеку, черги, асоціативних масивів.

------
      |
 List |
      |
------

Абстрактний тип даних, контейнер для елементів. Реалізації: linked list, array, dynamic array.
Думаю, тут малось на увазі тему dynamic array.
Динамічний масив - структура даних як масив, що позбута основної проблеми масивів - фіксована розмірність. Після повної заповненості при наступному додавані масиві збільшується у розмірі удвічі та відбувається копіювання елементів з старого у новий масив, тому операція займе O(N), замість константного часу. Також може бути імпелементовано зменшення розміру масиву при пересіканню нижної межі. Решта властивостей як у звичайного масиву.

-------
       |
 Queue |
       |
-------

Лінійна структура даних, колекція елементів, що дотримуються принципу First-In-First-Out. Основні операції: enqueue(додати елемент у колекцію), dequeue - вилучити елемент з колекції, peek - повернення елемента без вилучення з колекції.

Час операцій залежить від реалізації.
Додавання: Avarage - O(1), Worst - Array - O(N) due to resize, without resize - O(1), Linked List - O(1)
Видалення: Avarage - O(1), Worst - Array - O(N) due to shrink size, without shrink - O(1), Linked List - O(1)
P.S. Але походу resize/shrint не використовується, тому всьо константно, не кипишуй

Реалізація черги на основі:
1) Linked List
Enqueue:                       Dequeue:

if(head == null)               if(head == null) throw Empty;
{                            
  head = newNode;              var dequeueNode = head;
}else if(tail == null)         head = dequeueNode.Next
{                              return dequeueNode.Data;
  tail = newNode;
  head.Next = tail;
}else
{
  tail.Next = newNode;
  tail = newNode;
}

2) Array. Маємо індекс enqueueIndex = 0 та індекс dequeueIndex = 0. При вставці записуємо у масив з enqueueIndex та інкрементуємо індекс enqueueIndex. При Dequeue якщо dequeueIndex===enqueueIndex то черга порожня, інакже повертаємо елемент під індексом dequeueIndex та інкрементуємо dequeueIndex. Якщо при вставці enqueueIndex == array.Length та dequeueIndex  == 0, то ресайзим(переносимо від dequeueIndex до enqueueIndex), якщо не 0, то сетаємо enqueueIndex = 0 і вставляємо допоки enqueueIndex != dequeueIndex.


Priority Queue може бути реалізована за допомогою heap.

-------
       |
 Stack |
       |
-------

Лінійна структура даних, колекція елементів, що дотримуються принципу Last-In-First-Out. Основні операції: push(додати елемент у колекцію), pop - вилучити елемент з колекції, peek - дістати елемент, але не вилучати з колекції.

Час операцій залежить від реалізації.
Додавання: Avarage - O(1), Worst - Array - O(N) due to resize, without resize - O(1), Linked List - O(1)
Видалення: Avarage - O(1), Worst - Array - O(N) due to shrink size, without shrink - O(1), Linked List - O(1)
P.S. Але походу resize/shrint не використовується, тому всьо константно, не кипишуй

Реалізація стеку на основі:
1) Linked List
Push:                          Pop:

if(head == null)               if(head == null) throw Empty;
{                            
  head = newNode;              var popNode = head;
}else                          head = popNode.Next;
{                              return popNode.Data;
  newNode.Next = head;
  head = newNode;
}
2) Array. Маємо індекс вставки, який на початку 0. При Push вставляємо по індексу втсавці у масив та інкрементуємо індекс. При поп декрементуємо індекс та дістаємо елемент з масиву по індексу вставки. Якщо індекс вставки дорівнює довжині масиву, resize.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Для сортування масиву будь-якого розміру я використаю quick-sort, тому що хороша імплементація алгоритму quick-sort для малої довжини масиву переключиться на insertion-sort.

-----
     |
 BFS |
     |
-----

Алгоритм пошуку найкоротшого шляху у незваженому графі. Алгоритм проходиться по рівнях, допоки не знайте потрібну вершину.
Вибирається елемент як початкова точка, нульовий рівень. Вершини, з якими напряму зв'язаний нульовий рівень, важаються першим рівнем, ті що зв'язані з першим рівнем - другий.
Алгоритм:
1) У чергу додаються всі вершини, які зв'язані з попереднім рівнем і ще не були пройдені. Також записується батьківський елемент, щоб можна було побудувати знайдений найкоротший шлях.
2) Після вилучення з черги вершини, вершини, які з нею зв'язані з наступного рівня та не були вже пройдені, додаються дочерги
3) Алгоритм повторюється, допоки не буде знайдено шлях до потрібдної вершини. Перше знаходження і буде найкоротшим шляхом до неї.

Почати можна з будь-якої вершини, так як це не дерево і немає поняття 'root' ноди. Роботу BFS можна порівняти з розповсюдженням вірусу.

Worst-case complexity: O(V + E), V- vertex, вершина E - edges, ребра
Space complexity = O(V), черга з кількості V-вершин

-----
     |
 DFS |
     |
-----

Алгоритм пошуку шляху між двома вершинами. Алгоритм знаходить не найкоротший шлях, а перевіряє чи він існує. Алгоритм проходиться у глибину графу та якщо попадає у ситуацію, коли більше немає ребер до інших вершин, повертається назад та шукає ще невідвідані вершини. Схожий до пошуку виходу з лабіринту, якщо вперся у стіну, повертається до інших можливих шляхів.
Алгоритм:
1) Вибирається вершина як початкова точка. Поміщається у стек та маркається як відвідана
2) Якщо є хоч одне ребро, вибирається будь-яка з пов'язаних вершин, що не була відвідана, закидується у стек та маркається як відвідана та записується парент, щоб відтворити шлях.
Якщо немає ребер або всі ребра ведуть до вже відвіданих вершин, то з стеку вилучається дана веришина, та розглядаються невідвідані вершини попередньої.
3) Етап 2 повторюється, допоки не буде знайдено шлях до потрібної вершини або всі можливі шляхи або шляху не існує. У разі неіснуючого шляху, всі значення з стеку будуть вилучені, а остання вершина бути зв'язана уже з відвіданими вершинами.

Worst-case complexity: O(V + E), V- vertex, вершина E - edges, ребра
Space complexity = O(V), стек з кількості V-вершин

----------
          |
 Dijkstra |
          |
----------

Алгоритм пошуку найкоротшого шляху від одної вершини графу до решти у зважених графах.
Алгоритм:
1) Вибираємо вершину графу, з якої будемо шукати найкоротший шлях до решти вершин, шляхом сетання довжини шляху 0, а решта вершин - безкінечністю
2) Маємо два списки, пустий список вершин, яких вже відвідали, та повний список невідвіданих вершин
3) Вибираємо вершину, до якої найкоротший шлях, у даному випадку ту, яку ми сетнули 0
4) З вибраної вершини калькулюємо шлях до її сусідніх невідвіданих вершин
5) Якщо шлях менший за відомий до даних вершин, то апдейтим значення і сетаємо парент ноду, з якої прийшли.
6) Після цього додаємо вибрану вершину у список відвіданих вершин і вибираємо наступну сусідню вершину, яка має найменший шлях, і калькулюємо значення шляху до її сусідів та сетаєм парент ноду як у попередніх кроках
Якщо цікавить тільки знаходження шляху лише до одної конкретної ноди, тоді після знаходження першого шляху треба переривати алгоритм, так як він буде найшвидший, так як ми опрацьовуємо спочатку найкоротші маршрути.
Черга маршрутів можна реалізувати через priority queue

         Shortest distance
Vertex         from A
  A    |         0         |  
  B    |         3         |  D
  C    |         7         |  E
  D    |         1         |  A
  E    |         2         |  D

Якщо ми хочемо дізнатись найкоротший шлях від A до E, тоді ми беремо зі списку ноди E парент ноду D, з ноди D парент ноду A, це і є найкоротший шлях.

-------------
             |
 Bubble Sort |
             |
-------------

Сортує масив порівнюючи елементи та переставляючи місцями. Порівнює нулевий елемент з першим, переставляє місцями, якщо нулевий більший за перший, потім порівнює перший з другим, переставляє, якщо необхідно і так до кінця. Після першого проходу у кінці буде найбільший елемент і в наступній ітерації з ним порівнювати вже не потрібно. Після другої ітерації у кінці буде два найбільших елементи з якими не варто порівнювати. Можна перевіряти чи за один прохід хоч раз було свапнуто елементи, якщо не було, то break.

for (int i =0; i < arr.Length -1; i ++)
{
    for (int j = 0; j < arr.Length - i - 1; j++)
    {
        if (arr[j] > arr[j + 1])
        {
            var temp = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = temp;
        }
    }
}

Worst-case complexity: O(n^2)....O( (n(n-1)) / 2)) Reverse sorted
Avarage-case complexity: O(n^2)
Best-case complexity:  Якщо з break і вже відсортований масив, то O(N), а так O(n^2)
Stable: Yes
In-place sort: Yes
Просторова складність: O(N), допоміжний простір: O(1)

-----------
           |
 Heap-Sort |
           |
-----------

Алгоритм сортування, в якому масив розглядається як комбінація бінарного кучі(binary tree - parent нода має не більше 2 дітей, ліва чайлд нода і права + complete binary tree - лише останній батківскьий елемент може не мати 2 чайлдів + чайлди менші за батька) та задня відсортована частина масиву.
Після кожного сортування дерева, найбільший елемент, що знаходиться у root ноді дерева, переміщаться на початок відсортованого масиву, і довжина дерева скорочується на одне значення.
Алгоритм:
1) Шукаємо оcтанню батківську ноду, що має хоч одну дочірню ноду,s по формулі n / 2 - 1
   a) Переміщаємо у батківську ноду найбільше значення з батьківської-дочірних нод.
   б) Якщо переміщали з дочірньої ноди, то викликає алгоритм перебудови дерева з дочірної ноди як з батьківської
   в) Виконуємо цей алгоритм для всіх попередніх батьківських нод
2) Після цього у нас у root елементі найбільше значення, ми свапаємо останній елемент дерева з першим і віднімає від довижини дерева одне значення, щоб найбільший елемент, який тепер укінці
більше не враховувався.
   Виконуємо 1a-б-в для root ноди, допоки дерево не скаладється лише з одного елементу.

private static void HeapSort(int[] arr)
{
    int length = arr.Length;
    for (int i = length / 2 - 1; i >= 0; i--)
    {
        Heapify(arr, length, i);
    }

    for (int i = length - 1; i > 0; i--)
    {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        Heapify(arr, i, 0);
    }
}

private static void Heapify(int[] arr, int length, int i)
{
    int biggest = i;
    int left = i * 2 + 1;
    int right = left + 1;

    if (left < length && arr[left] > arr[biggest])
    {
        biggest = left;
    }

    if (right < length && arr[right] > arr[biggest])
    {
        biggest = right;
    }

    if (biggest != i)
    {
        int temp = arr[i];
        arr[i] = arr[biggest];
        arr[biggest] = temp;

        Heapify(arr, length, biggest);
    }
}

Worst-case complexity: O(nlogn)
Avarage-case complexity: O(nlogn)
Best-case complexity:  O(nlogn)
Stable: No
In-place sort: Yes
Просторова складність: O(N), допоміжний простір: O(1)

----------------
                |
 Insertion-Sort |
                |
----------------

Сортування масиву відбувається шляхом зсуву всіх елементів, що більше вибраного на одну позицію і вставлення вибраного елементу після першого елементу, який менший.
Як ми сортуємо карти у руках.

for (int i = 1; i < arr.Length; i++)
{
    var key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key)
    {
        arr[j + 1] = arr[j];
        j -= 1;
    }

    arr[j + 1] = key; //can check if was at least one swap if no then redundant setting. if j + 1 != i
}

Use: найкращий для сортування малих майже відсортованих масивів. Деякі реалізації quick-sort використову.nm insertion-sort, якщо довжина масива менше певного значення(~10 length)
Worst-case complexity: O(n^2) Reverse sorted Якщо треба кожен елемент переставляти на початок, тобто масив відсортовано у descending order
Avarage-case complexity: O(n^2)
Best-case complexity:  O(n) якщо вже відсортований
Stable: Yes
In-place sort: Yes
Просторова складність: O(N), допоміжний простір: O(1)

------------
            |
 Merge-Sort |
            |
------------

Алгоритм, який розділяє масив на менші, допоки не розділить до одного елементу, після цього відбувається збирання масиву у відсортованому порядку.

     8, 7, 4, 1

 8, 7          4, 1

8    7        4     1

---------------------

 7,8           1, 4
  
     1, 4, 7, 8


private static void MergeSort(int[] arr, int start, int end)
{
    if (start >= end)
    {
        return;
    }

    int mid = (start + end) / 2;
    MergeSort(arr, start, mid);
    MergeSort(arr, mid + 1, end);

    Merge(arr, start, mid, end);
}

private static void Merge(int[] arr, int start, int mid, int end)
{
    var tempArray = new int[end - start + 1];
    int i = start, j = mid + 1, tempArrayIndex = 0;

    while (i <= mid && j <= end)
    {
        if (arr[i] <= arr[j])
        {
            tempArray[tempArrayIndex] = arr[i];
            i++;
        }
        else
        {
            tempArray[tempArrayIndex] = arr[j];
            j++;
        }

        tempArrayIndex++;
    }

    while (i <= mid)
    {
        tempArray[tempArrayIndex] = arr[i];
        i++;
        tempArrayIndex++;
    }

    while (j <= end)
    {
        tempArray[tempArrayIndex] = arr[j];
        j++;
        tempArrayIndex++;
    }

    for (i = start; i <= end; i++)
    {
        arr[i] = tempArray[i - start];
    }
}

Worst-case complexity: O(nlogn)
Avarage-case complexity: O(nlogn)
Best-case complexity:  O(nlogn)
Stable: Yes
In-place sort: No
Просторова складність: O(N), допоміжний простір: O(N)

------------
            |
 Quick-Sort |
            |
------------

Сортує масив шляхом визнчення pivot та розміщення елементів, що менше pivot у ліву частину, ті, що більше у праву, після цього запускає сортування для масива елементів, що зліва, та масиву елементів, що cправа.
Pivot вибирається одним з наступних методів: pivot - останній елемент, перший, медіана або рандом.
Якщо pivot буде обраний на кожній ітерації найбільшим елементом у масиві, то це займе найбільше часу і буде схоже на Bubble Sort, при кожній ітерації у кінці буде відсортований + 1 елемент.

private static void QuickSort(int[] arr, int start, int end)
{
    if (start >= end)
    {
        return;
    }

    int pivot = Partition(arr, start, end);

    QuickSort(arr, start, pivot - 1);
    QuickSort(arr, pivot + 1, end);
}

private static int Partition(int[] arr, int start, int end)
{
    int pivotIndex = end;
    int i = start, j = start;
    for (; j < pivotIndex; j++)
    {
        if (arr[j] < arr[pivotIndex])
        {
            int temp = arr[i];          // Can check if j != i then swap, i ++ must be executed in any way
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
        }
    }

    int temp2 = arr[i];
    arr[i] = arr[pivotIndex];
    arr[pivotIndex] = temp2;

    return i;
}

Worst-case complexity: O(n^2)  if sorted ascending and pivot end element, on each iteration all elements go left and only one element sorted(pivot)
Avarage-case complexity: O(nlogn)
Best-case complexity:  O(nlogn)
Stable: Cтабільний, якщо рівні елементи переміщати у ліву частину(при pivot end element)
In-place sort: Yes
Просторова складність: O(N), допоміжний простір: O(1)

----------------
                |
 Selection-Sort |
                |
----------------

Знаходить у невідсортованій частині масиву найменше значення та свапає місцями з елементом на початку невідсортованої частини.

for (int i = 0; i < arr.Length - 1; i++)
{
    var minValueIndex = i;
    for (int j = i + 1; j < arr.Length; j++)
    {
        if (arr[j] < arr[minValueIndex])
        {
            minValueIndex = j;
        }
    }

    if (i != minValueIndex)
    {
        var temp = arr[i];
        arr[i] = arr[minValueIndex];
        arr[minValueIndex] = temp;
    }
}

Worst-case complexity: O(n^2)
Avarage-case complexity: O(n^2)
Best-case complexity:  O(n^2)
Stable: Default - No, but can be achived if  (arr[j] < arr[minValueIndex]) not  (arr[j] <= arr[minValueIndex])
In-place sort: Yes
Просторова складність: O(N), допоміжний простір: O(1)