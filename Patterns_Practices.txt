--------------------
                    |
 Coding Conventions |
                    |
--------------------

Сукупність вказівок до стилю оформлення коду, практик.

--------------------------
                          |
 Верифікація vs Валідація |
                          |
--------------------------

Валідація - підтвердження чи продукт розробляється відповідно до вимог, специфікації. Відповідає на запитання: Are we building the product right?
Верифікація - підтвердження чи продукт задовільняє потреби кінцевого користувача чи правильно було сформовані вимоги. Відповідає на запитання: Are we building the right product?

---------------------
                     |
 Integration Testing |
                     |
---------------------

Фаза тестування, у якій комібнуються units, modules, components та тесутються як одне ціле, щоб дізнатись чи поведінка взаємоді відповідає вимогам. 
Протестовані юніти в unit testing об'єднуються у групу та тестуються разом.
Модуль - логічне групування функціональності, наприкла клас, набір класів, юніт оплати, корзини(додавання видалення з корзини), оформлення замовлення.
Після інтеграції модулів і їх тестування відбувається системне тестування.
Підходи:
1) Big Bang - значна частина модулів збираєтсья разом формуючи завершену частину програми
2) Знизу-вгору - компоненти нижного рівня тестуються  спрешу для полегення тестування викокорівневих. Знаходження програмних дефейктів
3) Зверху-донизу - знаходження архітектурних дефектів
4) Сендвіч тестування - комбінація знизу-вгру та зверху-донизу

------------
            |
 Unit tests |
            |
------------

Метод тестування програмного забезпечення, який полягає у окремому тестуванні юніта програми незалежно від інших. Юнітом називають найменшу частину програми, яка може бути протестованою.
У об'єктно-орієнтованому програмуванні - це метод. Використовуються для того, що функціонал має очікувану поведінку. Написані тести допомагають у регресивному тестуванні, після рефакторинку чи введення нових змін результат
виконання тестів дасть зрозуміти чи старий функціонал працює коректно. Написання unit test позитивно впливає на взаємозв'язки між класами, щоб протестувати модуль, він має бути loose coupled з іншим, що неминуче приводить до
дотримування Dependency Inversion Principle. Клас повинен залежити від абстрації, а не від конкретної реалізації, без цього це буде не unit тестування, а інтеграційне. Тестування класу А перетікатиме у тестування класу Б,
що не відповідає unit тестуванню. Щоб уникнути цього, клас повинен залежити від абстракції. Це дозволить у тестових випадках підставити mock об'єкти чи stub.

Test doubles:
Dummy - об'єкт, який передається, але не використовуєься. Служить лише для заповнення обов'язкових параметрів.
Fake - об'кти, які мають робочу імплементацію, але відрізняються від реальних, що використовуютсья у продакшині. Спрощена версія реального об'єкту. Example: дао, який звертаєтсья не до бази даних, а in memory collection-store.
Stub - об'єкт, який містить заздалегідь визначені дані (predefined) та використовує їх при відповіді на виклики у тесті. For query methods. For command use Mock. Example: method that returns predefined string.
Spy - stub, яка додатково записує інформацію про виклик. Функціонал, який записує скільки листів надіслав.
Mock - врапер над реальним об'єктом, який реєструє його виклик, але не виконує його код. Use for command methods(CQS). Для перевірки, що всі необхідні дії(виклики) було здійснено.
Замість того, щоб реальний код виконувався, нам треба перевірити чи він просто викликається.
Нехай модуль викликає метод, який надсилає лист. Ми не хочемо при тесутванні, щоб надсилався лист, але хочемо впевнетись, що виклик методу був здійснений. Для цього функціонал надсилання мокається.
У модульному тестуванні нас не хвилюватиме чи лист надіслався правильно чи надіслався взагалі, у цьому тесті нас лише цікавило чи цей функціонал буде викликано, а надсилання може бути протестовано окремо.
Замокані об'єкти реєструють взаємодію.

Mock vs Stub - верифікація поведінки vs верифікація стану

Cекції unit test:
Arrange - підготовка середовища
Act - виклик коду, що тестується
Assert - перевірка очікуваного результату

-----------
           |
 SonarLint |
           |
-----------

IDE extentsion для безперервного аналізу коду, виявлення потенційних баг, проблем у коді, вразливостей.

-----------
           |
 SonarQube |
           |
-----------

Cервер для хостингу та аналізу ПЗ для виявлення потенційних баг, порушення стилю програмування, security вразливостей(OWASP TOP 10), code smell. Проводить статичний аналіз.
SonarQube & SonalLint - це продукти однієї компанії SonarSource, тому ці продукти використовуютсья одинакові аналізатори. SonarQube можливо підтримує більше функціональності і провайдить full analysis.

---------------
               |
 Message Queue |
               |
---------------

Асинхроний протокол передачі даних для реалізації inter-process communication or inter-thread.
Асинхроний, тому що продюсеру не потібно дочікуватись, коли консюмер отримає повідомлення. Черга повідомлень дозволяє двом процесам комунікувати один з одним, відправляючи повідомлення у їхні черги.
Після відправки повідомлення продюсеру не потрібно дочікуватись, допоки консюмер не отримає повідомлення, а може продовжити виконання. Консюмер прослуховує чергу і при поступлені нового повідомлення вилучає з черги у FIFO порядку.
Черга зберігає повідомлення допоки друга сторона його не отримає.
Message queue дозволяє розідленій великій системі, на менші системи, взаємодіяти асинхроно між собою. Ці роз'єданні ситеми можуть розвиватись незалежно, писатись на різних платформах, мовах,
легко замінятись на інші системи у разі необхідості.

--------------
              |
 Event-driven |
              |
--------------

Парадигма прогармування, у якій виконаня програми оприділяється подіями - діями користувача, повідомленнями від інших потоків або процесів, подіями операційної системи.
Використовується у графічних або інших застосунках, де потрібно виконувати певні дії у відповідь на input від користувача.
У такій програмі є event loop, який постійно прослуховує івенти та при поступлені викликає їх хендлери. Також у вбудованих системах event loop, можна замінити на hardware interrupts.
Так як для більшості програм event loop це спільна техніка, переважно фреймворки реалізують її самі, а програмісту лишається лише писати хендлери.
Так як подій може бути багато, то event loop не встигатиме передавати управління всім хендлерам, для цього івенти складаються у event queue, з якої по принципу FIFO обробляються.
Таких черг може бути декілька, одна для високо приорітетних подій, решта для менш. Відповідно допоки черга високо пріоритетних подій не пуста, решта черг не розглядаються.

------------
            |
 Functional |
            |
------------

Парадигма програмування, яка розглядає програму як обчислення функцій та уникає станів та змінних.
Функціональне прогармування являється декларативним, функції у цій мові операються тільки на аргументи, а зовнішній зміних немає.
Виклик одної функції з такими же самими параметрами видає завжди такий самий результат, так як програма не зберігає стану. Це дає змогу ефективно підкешовувати результати, розпалалелювати роботу, так як функції не мають side-ефектів
Такі функції називаютьяс чистими. В основі парадигми лежать лямбда вирази.
Мови: F#, Erlang, Haskell, Lisp

----------
          |
 Reactive |
          |
----------

Парадигма програмування, орієнтована на потоки даних та розповсюдження змін.
В імперативному програмувані присвоєння a = b + c означає, що у змінну а буде присвоєнно додавання поточних значень змінних а б і с, і при зміні b чи с значення а не зміниться.
У реактивному програмуванні значення а буде оновлено.
Реактивне програмування використовуєтсья у побудові інтерфейсу користувача, моделювання, анімації, які змінюютсья у реальному часі.
Цю парадигму можна використовувати, щоб автоматично відображувати зміни моделі(Model) на вигляді (View) і навпаки.

-----
     |
 ООП |
     |
-----

Парадигма програмування, що розглядає програму як сукупність об'єктів, що взаємодіють між собою через обмін повідомленнями.
Переваги ООП: модульність, перевикористання коду, легке впроваджування змін, опис об'єктів реального світу та їх взаємодії, дають чіткіше розуміння.
Основні концепції:

Інкапсуляція - механізм об'єднання даних та коду, що інкапсульовує ці дані та надає інттерфейс взаємодії з ними. Стан класу зберігається у його полях, ці поля не можна робити публічними, так як неправильне їх використання може призвести до некоректної роботи програми.
Тому дані полі повинні бути приватними, а доступом до них керує спеціальний код, що забезпечує безпечне управління цим станом. Наприклад, є поле вік людинм, якщо зробити публічним його, то певний клієнт може просетати це поле від'ємним значенням, що може вподальшому причинити неочікувану ситуацію.
Для запобігання цього код може валідувати значення, яке клієнт хоче просетати і якщо це значення від'ємне то перервати цю операцію.

Наслідування - механізм створення нових класів на основі вже існуючих. При цьому похідний клас переймає властивості та поведінку батьківскього класу. Дозволяє описувати ієрархічну моделю об'єктів реального світу.
Позбавляє від дублювання коду. Недоліком являється те, що при зміні базового класу, ці зміни можуть задіти поведіку похідного. Де можливо краще використовувати агрегація або композицію.

Поліморфізм - один інтерфейс - множина форм. Нихуя не понял, но очень интересно
Види:
Спеціалізований(Ad hoc polymorphism)- перевантаження функцій з різними параметрами
Параметризований - generics
Підтипів - об'єкти похідних класів можуть виступати як об'єкти базового, виконувати ту ж поведінку або овверайдити її.

Статичний - тип оприділяється під час компліції
Динамічний - ттип буде відомо під час виконання програми
Поліморфізм та наслідування доповнюють один одного. Об'єкти похідних класів можуть виступати як об'єкти базового, виконувати ту ж поведінку або овверайдити її.

Абстракція - зосередження на основних деталях і відкидання непотрібних. Наприклад, машина складається з величезної кількості деталей, до тисячі винтиків, при абстракції ми відділяємо лише колеса, двигун, салон.
Клас, що реалізовує інтерфейс або унаслідується від абстрактного класу, обов'язково імплементовує необхідну функціональність. При використанні класу через інтерфейс функціональність класу абстрагується(зосереджує на потрібному).
Відповідно, об'єкт абстракції не створити.

Обмін повідомленями

-------
       |
 SOLID |
       |
-------

Набір принципів для розробки системи, яку буде легко підтримувати та розширювати, зрозуміти, перевикористовувати її компоненти.

The Single Responsibility Principle - клас повинен вирішувати лише одну задачу. Якщо відповідальностей більше, то такий клас може стати супер класом, який вміє робити все, впровадужвати зміни у такі класи тяжко, може спричинити баги, low cohesion- слабо зв'язаний функціонал, що ускладнюватиме розуміння коду.
Проектуючи класи ми повині об'єднувати компоненти, зміни у яких відбуваютсья по одним і тим же причинам, і розділяти, у яких зміни по різних причинах. Слідування цьому принципу результує у high cohesion клас.

The Open Closed Principle - програмні сутності повинні бути відкриті до розширення та закриті до змін. Розшиення поведінки класів без можифікації їх
Відкриті до розширення мається на увазі, що поведінка класу може бути розширена шляхом створення новий підтипів сутності.
Закриті до змін - розширення не повинно модифіковувати існуючий код, так як на ця сутність вже використовується у програмі і це може призвести до баг, більше часу на тестинг.
Реалізовуєтсья за допомогою наслідування та поліморфізму.

The Liskov Substitution Principle - функції, які використовуються базовий тип, можуть використовувати підтип базового, навіть не знаючи цього. Це не повинно влпину на поведінку функції.
Клієнтський код, який використовує метод базового типу, при використанні об'єкта похідного типу не повинне змінювати своєї поведінки. Тобто похідні класи не повинні змінювати контракт поведінки базового класу.
Virtual - Override не порушуються LSP, якщо похідний тип підтримує сумісність поведінки.
Наприклад поіхдний клас у переоприділеному вірутальному методі не повинен викидувати вийнятки типу, які не є похідними від вийнятків, що викинує базовий клас.
Якщо ми пишемо код, який використовує метод базового класу і очікуємо, що він викидує ряд помилок таких типів, то всі похідні його підтипи можуть оверайдити, розширвувти поведінку методу, але не викидати помилки не тих типів або не похідних від тих типів, що базовий.
Підтипи можуть змінювати поведінку методу, але не повинні спричиняти зміну поведінки там, де вони викликаються, поведінку клієнта.
Есть базовый класс Stack, реализующий следующий интерфейс: length, push, pop. И есть потомок DoubleStack, который дублирует добавляемые элементы. Естественно, класс DoubleStack нельзя использовать вместо Stack.
Клієнт помістивши 4 елементи не очікуватиме отримати відповідь у 8.
Тип S будет подтипом Т тогда и только тогда, когда каждому объекту oS типа S соответствует некий объект oT типа T таким образом, что для всех программ P, реализованных в терминах T, поведение P не будет меняться, если oT заменить на oS.
Более простыми словами можно сказать, что поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода, использующего переменную базового типа.
Принцип Лісков є суворішим за поняття підтипу в теорії типів, яка вимагає тільки:
коваріантність методів за типом результату;
контраваріантність методів за типами аргументів;
заборону в методах підтипу викиду винятків, які не є похідними від типів винятків, що викидаються методами базового типу.

The Interface Segregation Principle - cутність, що реалізовує контракт, не повинна залежити від непотрібних їй методів, що оголошені у даному контракті.
Товсті інтерфейси треба розбивати на менші, що сутності реалізовували лише необхідні їм методи.

The Dependency Inversion Principle described below

---------------------------------------------------------------
                                                               |
 IoC vs Dependency Inversion Principle vs Dependency injection |
                                                               |
---------------------------------------------------------------

DIP - иодулі вищого рівня не повинні залежити від модулів нижчого, обидва повинні залежити від абстракції. Абстракція не повинна залежити від деталей, делаті повинні залежити від абстракції
Клас A, що містить у собі та контролює інший клас B, являється залежним від нього. Через зміну класу B, клас A також буде аффектнутий, що створює тісну залежність, якщо ми захочемо використовувати функціонал іншого класу
(вивід інформації у консоль(class B), на логування у файл(class C)), це займе значних зусиль. Клас А має приймати та оперувати інтерфейсом, що реалізує клас B, а не конкретною реалізацією. При створені класу А йому на місце інтерфейса
необхідно підставити конкретну реалізації інтерфейсу(клас B) у всіх місцях інстанціювання. Так як таких мість може бути багато, на допомогу приходить dependency injection.
Dependency Injection - паттерн, який дозволяє винести створення об'єкту, на який залежить клас, на зовні і досягти ще більшого рівня loose coupling. DI through constructor, property, method.
IoC контейнер - зв'язує абстракцію та реалізацію для застосунку та підставляє де необхідно.
IoC - принцип, у якому для досягнення loose coupling інвериться різні види контролю управління(application flow, object creation). Приклад: припустимо, що людина веде машину, що означає, що вона контролює її. ІоС пропонує інвертувати
контроль, людина наймає водія, який веде машину, а людина займаєтсья тільки своїми справами.
Замість того, щоб застосунок викликав методи фреймворку, фреймворк викликає методи застосунку. Контроль переходить у руки фреймворку і вирішує, коли необхідно смикнути методи застосунку(framework rise event, app handling it,for example).
Чи створення залежних об'єктів IoC контейнером.
Також може відноситись до того, що клас не інстанціює об'єкт іншого класу, а натомість отримує його ззовні або віддає створювати комусь іншому(Factory, ServiceLocator, IoC container).
Dependyncy inversion principle - компонент має залежити від абстракції, а не від конкретної реалізації. IoC - віддай управління по створеню об'єкта комусь іншому, та зосередся на своїх обов'язках.
Service Locator - статичний клас або об'єкт класу(singleton), який повертає всі необхідні залежності застосунку(Registry).

Tightly coupled - залежний клас створює об'єкт іншогго класу та використовує його.
IoC - залежний клас усередині віддає створення об'єкту фабриці.
DI - залежний клас приймає об'єкт класу через конструктор, метод, пропертю.
IoC(DI) контейнер - імплементовує автоматичне dependency injection, керує створенням об'кта його life-time, та інджектить залежності у клас.
Register - зв'язує абстракцію з реалізацією
Resolve - створює залежість та інджектить у залежний клас
Dispose - керує лайф-таймом об'єкта та дізпоузить

-----
     |
 DRY |
     |
-----

Принцип розробки ПЗ, цілю якого являється уникнення дублювання інфомації будь-якого роду. Будь-яка інформація повинна мати єдине, однозначне, авторитетне представлення в системі.
Модифікація одного елементу не вимагатиме зміни іншого, коли досягається перевикористання елементу.

------
      |
 KISS |
      |
------

Принцип розробки ПЗ, мета якого досягнення максимальної простоти системи. Cтверджує, що система працює краще, коли вона проста, ніж складна. Непотрібна складність повинна бути упущена.

-------
       |
 YAGNI |
       |
-------

Принцип розробки ПЗ, слідування якого призводить до відмови від додавання додаткової функціональності без реальної потреби в цьому, так як це:
- займе додатковий час на розробку, тестування, документування
- не факт, що знадобиться
- збільшить кількість потенційних баг
- потенційне ускладення ПЗ
- цей функціонал може у майбутньому обмежити або ускладнити розробку іншого функціоналу
- розробка додаткового функціоналу може призвести до бажання додати ще, ефект снігової кулі

-----
     |
 UML |
     |
-----

Unified Modeling Language - уніфікована мова моделювання, стандарт, що використовує графічні позначення для створення абстактно моделі системи, що називається UML-моделлю.
Структурні діаграми: класів, компонентів, розгортування, об'єктів, пакетів.
Діаграми поведінки: діяльності, станів, прецедентів
Діаграми взаємодії: кооперації, послідовності, синхронізації
