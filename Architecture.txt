-------------
             |
 Actor Model |
             |
-------------

Концептуальна модель у параленьних обчисленнях.
Все є актором. Актор - це одиниця обчислення. Кожен актор має приватний стан, який не може бути модифікований ззовні, поштову скриньку, в яку надходять повідомлення від інших акторів.
Актор може знати адресу іншого актору, якщо створив його, або отримав адресу у повідомлені.
Повідомлення зі скрииньки оброблятються послідовно. Щоб обчислити паралельно, необхідно створити відповіду кількість акторів.
Актори ізольоваі один він одного і не шарять пам'ять між собою.
Актор, отримавши повідомлення, може здійснювати наступні дії:
1) Створити акторів
2) Надіслати повідомлення іншим акторам
3) Визначити, що робити з наступним повідомлення. Визначити як його приватний стан буде виглядати для наступного повідомлення, не змінюючи його зараз.

Відмовостійкість.
Тут притримуються філософії 'let it crush', так як всі точки падіння неможливо вичислиит та покрити.
Тому існуються актори(supervisor), які наглядають за іншими акторами. Якщо актор закрешиться, то supervisor відповідальний за те, щоб виконати певні дії, щоб відновити роботу актора.

------
      |
 CQRS |
      |
------

Спочатку варто розглянути CQS.
Command query separation - підхід, у якому метод являється або командою, або запитом, но не одночасно тим і іншим.
Команда - може змінювати внутріншній стан програми та не повертає значення.
Запит - повертає дані, але не може змінювати внутрішній стан.
Це розділення доволяє бути впевненим, що при виклику запиту, не буде ніяких side-ефектів.
Задавання запитання не повинно змінювати відповідь.

Command Query Responsibility Segragation - архітектурний паттерн, який застосовує СQS на архітектурному рівні. Використовується для поділу на модель запису та модель зчитування, що збільшує продуктивність,
дозволяє маштабоватись незалежно та налаштовувати незалежно захист. Вирішує проблеми невідповідносі доменої моделі від її представницької моделі.
Нехай у нас є сервіс, який здійснює певні дії. Ми розділяэмо його на два сервіси, один - на запис, другий - зчитування. Можемо піти дальше і розділити застосунок на
write application та read application. Кожен застосунок може писатись на іншій платформі, використовувати іншу технологію. Ми можемо віддати розробку даних застосунків різним командам, 
що пришвидше роботу. Read application можна віддати фронтендерам, які переважно знають Node.js. Так як 80% запитів припадають на вичитку даних, можна виділити більше серверів на read application.
Для розробки read applciattion девелоперу не треба знати ідеально бізнес модель, так як він буде оперувати лише з моделю представлення, а домена модель буде на стороні write applciattion,
що значно полекшить і пришвидше роботу, а також звільне від проблеми, коли модель, якою ми оперуємо і зберігаємо у базу даних, відрізняєтсья від моделі, що ми відображаємо користувачу.
Якщо розділеня applciattion неоправдана складність, то для зчитування буде використовуватись read service з read model, а для запису - write service з domain model. 
Також ми можемо розділити базу даних на write i read бази. Як і з application, можуть використовуватись різні бази(SQL, No-sql бази) залежно від потреб. Write база буде відповідати доменій моделі,
у той час як read база може бути денормалізована для більш швидкої вичитки. Залишається питання, як тримати read базу у консистемному стані, так як дані пишуться у write базу.
Для цього можна використати Domain Event та Event Sourcing(івенти, які записуються у базу, райзяться для read application, який оброблєю і модифікує read базу)

---------------------
                     |
 Anemic Domain Model |
                     |
---------------------

Домена модель, у якій присутня мінімальна кількість логіки або не присутня взагалі. Така модель складається тільки з геттерів та сеттерів, виглядає як DTO.
Бізнес логіка(правила, валідації) винесена у сервіси, що сильно роздуває їх.
Anemic model порушує інкапсуляцію, дані і логіка, що контролює доступ до даних, повинні знаходитись якомога бижче. Анемічна модель не забороняє містити моделі бізнес логіку, що може спричинити ситуацію, коли не буде зрозуміло чи для досягнення цілі можна використати модель з певною частиною бізнес логіки чи треба використовувати сервіс для доступу до доменої моделі.
У DDD використовується Rich Domain Model. У такій моделі сервіси максимально тонкі і не містять бізнес логіки, а лише делегують виклики моделі, яка містить всю бізнес логіку застосунку.
Переваги:
1) Чіткий розподіл на дані та логіку
2) Добре підходить для простих застосунків
3) Уникнення складного шару мапінгу доменої моделі в дата модель і навпаки

Недоліки:
1) Порушення інкапсуляції та data hiding, не трушний об'єктно-орієнтований дизайн
2) Домена модель не може гарантувати валідний стан у будь-який момент часу, так як логіка міститься від частини у сервісах, від частини у самій моделі.

Anemic

class Box
{
    public int Height { get; set; }
    public int Width { get; set; }
}

Non-anemic

class Box
{
    public int Height { get; private set; }
    public int Width { get; private set; }

    public Box(int height, int width)
    {
        if (height <= 0) {
            throw new ArgumentOutOfRangeException(nameof(height));
        }
        if (width <= 0) {
            throw new ArgumentOutOfRangeException(nameof(width));
        }
        Height = height;
        Width = width;
    }

    public int Area()
    {
       return Height * Width;
    }
}

------
      |
 POCO |
      |
------

Plain Old/CLR Object(POCO or POJO) - звичайний об'єкт, який не посилається ні на який фреймворк чи бібліотеку, не наслідується чи реалізовує від абстракцій певного фрейморку, не слідує його обмеженням. Такий об'єкт може бути використаний у будь-якому ORM.
До EF 4 класи наслідувались від EntityObject, що приносило залежність до конкретного фреймворку. Починаючи з 4 версії EF підтримує POCO-модель.

-----
     |
 DDD |
     |
-----

Domain-driven design(предметно-орієнтоване проектування) - підхід для перенесення знань про домен у об'єкто-орієнтоване програмне забезпечення.
Домен - це предметна область, яку необхідно автоматизувати.

Переваги полягають в наступному:
Концентрація основної уваги на предметній області, які є сутності, як вони взаємодіють;
Створення програмних моделей, які відображують глибоке розуміння предметної області і внесення подальших змін стає більш простішим.
Використовується для бізнесу зі складною логікою і поступаючими новими змінами, так як DDD доволі скаладний підхід і для простого застосунку він буде неоправданий.
Модель - системна абстракція, що описує аспекти домену і використовується для вирішення задач цього домену.
Для розуміння домену, необхідно спілкуватись з доменими експертами на загальній мові
Domain експерти - особи, які знають як працює домен і його бізнес-процеси. Можуть не бути технічними спеціалістами.
Єдине/Загальна мова(Ubiquitous language) - набір термінів, що застосовується в моделі домену. На ній мають говорити всі учасники розробки пз(замовник, команда). Єдина термінологія.
Одне слово у різних контекстах може мати різні значення.
Context - середовище, в якому певне слово набуває свого значення.
Bounded context - розділення великої моделі на sub-моделі. Уніфікація доменої моделі для великої системи може бути неможлива або неефективно, тому DDD розділяє велику систему на Bounded Context, кожен з яких має свою уніфіковану модель.

Шаблони проектування:
Entity - унікальна сутність, яка оприділяється по ідентифікатору
Value object - незмінний об'єкт, який не має ідентичності. Два об'єкти з одинаковими значеннями атрибутів не розрізняються у програмі.
Entity vs Value object - що вибрати, залежить чи треба вам одинакові об'єкти розрізняти між собою. Наприклад, 500 грн для касира - value object, немає різниці який віддати, для криміналіста - entity, треба розрізняти для доказів
Aggregate - композитна сутність, яка складається з Entities & Value objects, має ідентифікатор, гарантує атомарність змін, забороняє зовнішнім об'єктам посилатись на членів агрегату. Доступ до членів здійснюється лише через агрегат.
Якщо одна entity може міститись у двох агрегатх, то така entity стає також агрегатом.
Repository - Доступ до агрегатів. Колекція об'єктів у пам'яті.
Factory - відповідальна за створення комплексних об'єктів  та aggregate
Service - виконує операції над моделю домену. Логіка з контролеру виноситься до сервісів для подальшого перевикористовування іншими застосунками. Серсів може використовувати інші сервіси та репозиторії

-----
     |
 ESB |
     |
-----

Enterprise Servce Bus - програмне забезпечення, що здійснює комунікацію між сервісами у сервіс-орієнтоавній архітектурі. Центральна система, що здійснює обмін повідмолень між сервісами.
ESB знає про всі сервіси. Так одному сервісу не треба звязуватись напряму з іншими сервісами і він про них не знає, а вся логіка інкапсульована у ESB. 
Несумісні по протоколу обміну повідомленнями між собою сервіси, можуть спілкуватись через ESB.
Переваги:
1) Кешування. 
2) Моніторинг та логування
3) Security enforcment
4) Load balancing
Недоліки:
1) Single point of failure
2) Міситить інформацію про всіх і вся, що сильно роздуває її, і ускладньє впровадження змін.

----------------
                |
 Event Sourcing |
                |
----------------

Архітектурний паттерн, у якому зміни до стану застосунку зберігаються як послідовність подій. Таким чином ми не зберігаємо стан сутностей у базі даних, а лиш події, які відбувались
з даними стностями, що дозволяє відтворити стан сутності за будь-який проміжок часу.
Поточний стан сутності можна отримати, відтворивши всі події над об'ктом.
Події зберігаються у event store, база даних подій. Події з бази не видаляютсья та не змінюються, а лише добавляються.
Допомагає з консистентністю між розподілених систем(eventual consistency), так як створені події можна райзити, а інші системи можуть захендлити дані події і віреагувати на ниї.
Дозволяє вести аудит. А також відповісти не лише як змінився стан, але й чому(клієнтПереїхавІвент)

Банк хранит сведения о том, где проживают их клиенты и в один день происходит изменение одного из почтовых адресов. При хранении информации в таблице, мы максимум сможем увидеть, что запись обновилась. Если был подключен аудит, то в целом мы можем посмотреть на историю всех предыдущих значений. Но сможем ли мы узнать, почему она изменилась: может это была изначальная ошибка?, а может клиент переехал в другое место? С помощью Event Sourcing мы как раз и смогли бы ответить на этот вопрос, т.к. у нас было бы 2 события: КлиентПереехал, ИсправленаОшибкаАдреса.

----------------------
                      |
 Layered Architecture |
                      |
----------------------

У Layered Architecture застосунок складається з компонентів, які згруповані по функціональності - layer. Розподіл згрупованої локіки по функціональності у layer, для кращого розуміння, тестування, розподілу обов'язків, зменшення мішанини коду і залежностей.
Наприклад, простий застосунок може складатись з насутпних layer'ів:
1) Presentaion layer - layer з яким взаємодії користувач, наприклад, веб-сторінка, Desktop UI. Також можна назвати клієнтом
2) Application layer - layer, який інкапсульовує бізнес логіку(business rules & data valdiation) застосунку, дані, DAL
3) Data layer - місце збереження даних застосунку, наприклад база даних.
Presentaion layer не треба знати де лежать дані і як їх дістати. Розподіл обов'язків.
Якщо розмістити кожен layer горизонтально, то layer може взаємодіяти лише з layer, що знаходиться під ним, і не може знає про решту. Цей концепт відомий як layers of isolations.
Дозволяє зменшити залежності так, що зміни до одного layer'а не будуть задівати всіх layer'ів, а лише layer, що знаходиться вище. Такі layer називають закритими. Деколи є сенс зробити якийсь layer відкрити, щоб layer вищого рівня міг перескочити його.
Наприклад, між Business layer і Persistence layer існує layer утиліток чи логування, який не має бути доступний вище, наприклад з Presentaion Layer, але і Business layer не завжди має проходити до Persistence layer через layer утиліток.
Немає визначеної кількості layer, що має бути у застосунку. Кожен layer, за необхідності, можна поділити на менші.
Наприклад,
Presentaion layer на:
1) Client layer - layer з яким взаємодії користувач, web-page, WPF client, Windows Forms
2) Client Presentaion layer - проміжна ланка між графічним інтерфейсом і бізнес логікою застосунку. ASP.NET MVC, Web Api
Applciation layer на:
1) Business layer(domain layer) - бізнес логіка зстосунку 
2) Persistence layer(DAL) - доступ до даних

Якщо розглядати ознаку n-tier архітектури, то треба зрозуміти, що таке tier.
Tier - Фізичний сервер. Layer може бути розгорнутий в одному tier, так і декількох tier'aх, як і всі layer можуть бути розгорнуті в один tier.
Якщо layer'и знаходяться у різних tier або процесах, вони повинні реалізовувати один з видів inter proccess communcation(socket, message queue, shared memmory).
Якщо layer працює у індивідуальному процесі, то він в теорії може працювати у індивідуальному tier, якщо inter proccess communcation не shared memmory.
Кількість tier'ів архітектури визначається кількістю layer'ів, що розгорнуті на різних серверах. 
Також 3 layer'и можуть бути на одному сервері, але працювати у 3 різних процесах, що означає, що це tree-tier architecture задеплоїна як 1-tier architecture

1-Tier: всі layer мають працювати на одному комп'ютері у одному процесі. Для цього має бути використана embedded database, яка не може працювати у індивідуальному процесі(MS Access)
2-Tier: всі layer не можуть працювати на більше ніж 2 комп'ютерах або процесах. Або Presentaion layer  і Application layer знаходяться у одному процесі або Application layer і Data Layer.
Переваги:
Простота і продуктивність, за рахунок роботи у одному-двох процесах, при малій кількості користувачів. Легший деплой, витрати на залізо.
Недоліки:
При збільшені кільксоті користувачів не здатна маштабуватись та розширювати захист

3-Tier: всі layer повинні працювати на 3 комп'ютерах або процесах. Embedded database недопустима.
N-Tier: layer мають бути поділена дальше і бігати на відповідній кількості компютерах.
Переваги:
Маштабування кожного з layer'ів.  Load balancing
Security contol. Можна налаштовувати захист для кожного з layer'ів.
Кожен layer можна модифіковувати незалежно і розгортати нову версію за потреби не зачіпаючи інших
Простіший девелопмент за рахунок розділення.
Недоліки:
При малій кілкьості користувачів менша продуктивність через більшу кількість процесів.
Вартість заліза.

-----
     |
 SOA |
     |
-----

Service-oriented architecture - архітектурний стиль, що був призначений для розбиття монолітних застостосунів на менші компоненти, які комунікують між собою, сервіси. Сервіс - самодостатній юніт застосунку, який виконує конкретне завдання.
Сервіси можуть варіюватись у розмірі від малих до великих ентерпрайзних. Один сервіс може складатись з декількох. Всі вони взаємодіють через ESB, являєтсья координатором, і використовують одну базу даних.
Незважаючи на розподіл моноліту на сет сервісів, у архітектурі високий рівень взаємозалежності, і зміни до одного сервісу призводять до редиплою решти, що може бути затратним процесом.
В SOA сервіси - course grained(грубозернисті), притримуються принципу 'share-as-much-as-possible', націлені на перевикористовування бізнес функціональності.

---------------
               |
 Microservices |
               |
---------------

Архітектурний стиль, у якому застосунок складається з колекції слабо зв'язаних, незалежно розгортаємих сервісів. Сервіс виконує одну бізнес функцію і робить це дуже добре. Для цього вони містять все необхідне, щоб виконати ціль. Являютсья
fine grained, на кожну бізнес функцію створюється окремий сервіс, який відповідальний лиш за цю функцію. Кожен сервіс працює у індивідуальному процесі і може redeploy індивідуально, також маштабуватись, при падіні одного сервіса,
решта не будуть зачеплені.
Спілкуються через language agnostic API. Надають перевагу дублюванню коді, аніж взаємодії з іншим сервісом, 'share-as-little-as-possible'. Децентралізований підхід.
Кожен сервіс може мати власну базу даних, але необхідно реалізовувати механізм розподілених транзакцій для підтримки даних у різних сервісах консистентними. Прекрасно працюються в парі з контейнерами. Легкий для освоєння новачкам.

-----
     |
 MVC |
     |
-----

Model View Contoller - архітектурний паттерн, який поділяє застосунок на три компоненти.
1) Модель - бізнес логіка та дані застосунку, які реагують на команди контролера, змінюючи свій стан
2) Вигляд - представлення моделі користувачу у певному форматі
3) Контролер - інтерпретує дії користувача у команди до моделі. Отримує user input, може валідувати його і віддавати моделі для опрацювання.
Використовується для відокремлення моделі від її представлення та контролера. Модель не знає про інші компоненти і не залежить від них. Так одна можель може мати декілька виглядів.
Паттерн вносить розподіл обов'язків і послаблює залежності(Loose coupling), дозволяє паралельний девелопмент. High cohesion - логічне групування коду у компоненти.

------
      |
 REST |
      |
------

REST - архітектурний стиль, який використовується для побудування веб-сервісів для підвищення продуктивності, маштабованості, простоти використання.
REST - набір обмежень, які накладаються на веб-сервіс. Веб-сервіс, що не порушує обмеження називаєтсья Restful

1) Mодель клінєт-сервер (Маштабування, розподілення відповідальності між зберіганням та оновлення даних та їх відображенням)
  Розподілення учасників comunnication на клієнта та сервера. Сервер - поставщик послуг, клієнт - споживач. При розподілені, кожен учасник може модифіковуватись, маштабуватись, незалежно один від одного.
  Клієнту не треба знати про базу даних, а серверу відповідати за інтерфейс користувача.
  Сервер не залежить від конкретної реалізації клієнта. Телефон, планшет, десктор, браузери.
2) Відсутність стану
  Сервер не містить інформації про стан клієнта. Всю необхідну інформацію для виконанння запиту клієнт надсилає разом з запитом і сервер не має знати ще щось з попереднього запиту, щоб його виконати.
  Попередній запит не повинен впливати на інший. Цим саме сервер звільняється від додаткової роботи. Це не означає, що стану немає, про нього не знає сервер. Cесійний стан повинен міститись на стороні клієнта.
  Так сервер після закінчення обробки запиту може звільнити всі ресурси, задіяні для цієї операції, без жодного ризику втратити цінну інформацію. Мінус - передача потенційно великого обєкту (auth cookie)
3) Кешування (Продуктивність)
  Проміжні вузли можуть кешувати відповіді, що підвище продуктивність. В свою чергу клієнт має знати чи була відповідь закешована, щоб не отримувати застарілі(stale) дані.
4) Шарова архітектура.
  Клієнт не знає чи він спілкується на пряму з сервером чи проміжним вузлом. Проміжні вузли можуть відповідати на запити клієнта.
5) Код на вимогу (Опціонально)
  У відповіді на запит клієта може міститись код, що розширує функціональність (Javasctipt)
6) Уніфікований інтерфейс(Простота у використані)
  Cпрощує взаємодію між компонентами через виділення загальні правила взаємодії. Спрошує і розділяє архітектуру так, що кожна частина може розвиватись незалежно.
  Ресурс - будь-яка одиниця інформації, яку можна назвати і сервер може надавати доступ до неї для перегляду та виконування певних операцій над нею.
  a) Ідентифікація ресурсу
    Кожен ресурс індентифікується за допомогою URI(Uniform Resource Indentifier). Конкретні реалізації URI: URL, URN.
	URL(Uniform Resource Locator) - адреса ресурсу. URN(Uniform Resource Name) - ідентифікатор, за яким можна визначити його адресу(URL). Локація може змінюватись, за допомогою URN можна завжди її визначити. 
	На подобі IP і domain name + DNS.
  б) Маніпуляція ресурсом за допомогою представлення
    Представлення ресурсу - це  відображення ресурсу клієнтові у певному форматі(HTML, JSON, XML, etc.)
	Якщо клієнт має представлення ресурсу, він має достатньо інформації, щоб модифікувати або видалити ресурс.
  в) Самоописові повідомлення
    Кожне повідомлення містить достатньо інформації як його обробити. Наприклад, отримане представлення ресурсу знає як його відобразити.
  г) Гіпермедіа як рушій стану застосунку
    Після доступу до будь-якого ресурсу на сервері через URI, клієнт отримує всі доступні дії через гіперлінки і може продовжувати далі без знання URI, а навігуватись до необхідних ресурсів і дій над ними за допомогою гіперпосилань.
	
------
      |
 SAGA |
      |
------

Saga pattern - архітектурний патерн для імплементації транзакції, що розповсюджується на декілька сервісів. Використовується для підтримки даних сервісів у узгодженому(consistent) стані.
Наприклад, один сервіс виконав певну дію(створив замовлення) і далі виконуються дії у інших сервісах(зняття суми з балансу клієнта). Якщо зняття грошей пройшло невдало необхідно здійснити відповідні дії з замовлення(видалити або скасувати)
Saga - послідовність локальних транзакцій. Кожен зі сервісів виконує власну тразакцію і паблішиться івент про успішне або не успішне виконання, який призводить інший сервіс до виконання транзакції або відкочення змін.
У разі неуспішного виконання транзакції, кожен зі сервісів виконують compencation actions для відкочення змін. Compensation actions - це код, який анулює результат виконаної дії.
На відміну від 2PC (Two phrase commit) результат виконаної локальної транзакції видимий до закінчення решти транзакцій.
Види координації:
1) Хореографія - кожен сервіс після виконаної транзакції паблішить про це домений івент, що призводить до виконання транзакції у іншому сервісі
2) Оркестрація - оркестратор віддає команди сервісам.
Існує три workflow по відкоченю змін:
1) Backward - при помилці у виконанні транзакції у одному з сервісів, всі попередгьо виконанні дії відкочуються за допомогою compencation actions
2) Forward - у цьому випадку при винекненні помилки, операція здійснюєтсья повотрно, доки не виконається успішно. Мінусом являєтсья те, що операція може не виконатись ніколи успішно і так процес зациклиться назавжди.
3) Backward/Forward - при помилці відкочується всі дії до певного "save point", і з нього починається знову виконання дій.

--------------------
                    |
 Onion Architecture |
                    |
--------------------

Представляє собою розділення застосунку на шари. У центрі аріхітектури розміщений незалежне ядро, яке огортає певна кількість шарів, що залежать від внутрішніх шарів.
Немає визначеної кількості шарів. На відміну від layered architecture, у onion третій шар може залежити від першого.
У центрі знаходиться Domain Model, класи, які описують ентіті бізнесу, що використовуються у застосунку та зберігаютсья у базі.
На рівні вище знаходиться шар Domain Services - інтерфейси для репозипоріїв. Ці два шари формують Domain/Application Core
Наступний шар Appliciation Services - інтeрфейси сервісів. Попередні шари були абстакті, database agnostic.
Далі слідують інфраструктурний шари. Перший - реалізації репорзиторіїв, другий - реалізації сервісів, третій - веб-інтерфейс