----------------------------------------------------
                                                    |
 Indentification vs Authentication vs Authorization |
                                                    |
----------------------------------------------------

Ідентифікація - процедура розпізнавання особистості за допомогою індетифікатора. Логін
Аутентифікація - процес підтвердження особистості. Пароль
Авторизація - процедура визначення прав доступу до ресурсу.

----------------------
                      |
 Basic Authentication |
                      |
----------------------

Тип аутентифікації, у якій логін та пароль передаються у http header Authentication у форматі Basic login:password, які закодовані у base64. Так як ця стрічка може бути легко декодована,
цей тип аутентифікації повинен використовуватись з механізмами сесюрності як TLS/SSL 
При кожному ріквесті має буде вказаний даний хедер, тому браузери підкешовують креди на певний період часу.
Також можна скористатись URL Encoding, передати логін та пароль у URL у форматі https://login:password@domain, але цей спосіб deprecated

-------------------------
                         |
 N-factor Authentication |
                         |
-------------------------

Фактор - метод аутентифікації.
Factor #1 Something you know: Те, що тільки одна людина знає, пам'ятає. Пароль
Factor #2 Something you have: Фізична річ, якою володіє лише ця людина. Token - фізичний девайc, який генерує код(програмний token). RSA SecureID. Чи карта-перепустка(smart card)
Factor #3 Something you are: біометрія: відбиток пальца, скан сітчатки ока, голос, обличчя.
Factor #4 Somewhere you are: локація. IP, MAC
Factor #5 Something you do: picture password

N-factor Authentication - механізм аутентифікації, який використовує n різних факторів та валідуються одночасно. Валідація введеного пароль і токена відбуваєтсья одночасно і якщо дані невалідні, хацкер не буде знати який з факторів
не пройдено.
Two-step Authentication - механізм аутентифікації, при якій спочатку валідується перший фактор і якщо він валідний, відбуваєтсья аутентифікація через другий фактор, який може бути такий самий. Example:
1st step - smth u knwow, 2st step - smth u knwow or have
One time password, який приходить на телефон, з секюрної сторони являєтсья something you know, а не have, тому що ключем являєтсья не володіння телефоном, на який прийде пароль, а сама інформація, яка може бути перехоплена.

------------------------------
                              |
 Resource-based Authorization |
                              |
------------------------------

Авторизація, яка залежить від ресурсу, до якого намагаються доступитись. Наприклад, редагувати докумет може тільки автор, отже спочатку необхідно дістати документ або його метаінформації та звірити чи автор відповідає користувачеві.
Ця авторизація не може відбуватися до виклику функції, як role-based чи claims-based.

----------
          |
 Identity |
          |
----------

Identity - інформація про юзера, хто він, його дані.
Asp.Net Idnetity - identity maangement cистема. Функціональність: Password validation & hashiing, User lockout, External Logins(From IdentityProviders), tokenization.
Asp.Net Identity не відповідає за аутентифікація та авторизацію у застосунку, але видає identity юзера, яка може використовуватись у цих цілях.  
На основі Asp.Net Identity можна використовувати claims-based auth or role-based.

Manager - how App interacts with Asp.Net Identity. UserManager, RoleManager
Store - how Asp.Net Identity interacts with database. IUserStore, IRoleStore
IUser <out TKey>
{
  TKey Id { get; }
  string UserName { get; set; }  
}
IdentityUser - EntityFramework realization
UserManager<IdentityUser> - CRUD User Indentity, set claims, password checking
UserStore<IdentityUser> - абстрація сховища даних. Реалізація може бути для sql, no sql db
При власній реалізації IUserStore можна підключати функціональність за допомогою наслідування IUserStore
public classMyUserStore: IUserPasswordStore, IUserEmailStore, IUserLoginStore, IUserPhoneNumberStore, IUserLockoutStore
UserManager у конструкторі приймає IUserStore і оперує ним, являється database agnostic, а вся dal логіка заключена у реалізації IUserStore
Якщо якусь функціональність не реалізовано під виглядом IUserStore, виклик методу по цій функціональності в UserManager викине помилку unsupported. if(!_userStore is IUserPasswordStore) throw new Exception();
UserManager.UserValidator && UserManager.PasswordValidator

Аутентифікація - Owin Helpers & Extentions
SignInManager

------------

            |
 JWT Bearer |
            |
------------

JWT - стандарт, який визначає спосіб передачі даних у вигладі JSON об'єкта. Токен містить сигнатуру, за допомогою якої можна визначити чи було змінено вміст токену.
Токен сам по собі не зашифрований і вміст може прочитати будь-хто, тому у такому токену не варто передавати sensitive data. Шифрування може бути здійснено за допомогою TLS, JWE.
JWT Token:
1) компактні(Compact)
2) Самодостатні(Self-contained). Містять всю необхідну інформацію, що дозволяє зменшити кількість запитів до бази даних.
Використоувається при:
1) Аутентифікації. OpenID Connect відправляє ID Token, що являєтсья JWT Token.
2) Авторизація. Може використовуватись як access token. Payload може містити дані авторизації(ролі і тд).
3) Обміні інфомрації, яку неможливо підмінити.
JWT token складається з трьох частин:
1) Header
Містить поле type, яке завжди дорівнює "JWT", та alg - алгоритм шифрування, який використовуєься у формувані cигнатури.
{
  "type": "JWT",
  "alg": "HS256"
}
2) Payload. Містить claims, дані, які необхідно передати. Існуютсья зарезервовані claims: sub, iss, aud, exp, iat,nbf.
3) Signature. Частина, яка підтверджує цілісність даних. Складається з закодованих у base64Url форматі header та payload та зашифровані алгоритмом вказаним у header.
Шифрування може бути використане симетричне(HMAC algorithm) або асиметричне(RSA || ECDSA).
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
JWT Example: base64UrlEncode(header) + "." + base64UrlEncode(payload) + "." + signature
Після аутентифікації cервер створює клієнтові jwt token та відправляє у response. При кожному ріквесті клієнт включає token у Authorization хедері з схемою Bearer: Authorization: Bearer <token>. Після валідації токена cервер може
використовувати claims з payload, та зменшити запити до бази даних за інформацією про юзера.

----------------
                |
 Single Sign-On |
                |
----------------

Технологія, що дозволяє користувачеві переходити з одної системи в іншу пов'язану систему без повторної реєстрації. Користувач логіниться у authentication system і отримує доступ до всіх підсистем.
1) Користувач заходить на domain1
2) Domain1 бачить, що auth cookie немає, значить користувач не аутентифікований і редіректить на систему аутентифікації
3) Користувач аутентифікується
4) Сервер аутентифікації сетає cookie , що користувач аутентифікований на сервері аутентифікації, редіректить користувача на domain1 з токеном
5) Domain1 валідує токен і сеттає cookie domain1, що користувач аутентифікований на domain1, з цією кукою не прийдеться більше редіректити на сервер аутентифікації
6) Користувач ходить по domain1 і надсилає з кожним ріквестом domain1 cookie
7) Користувач заходить на domain2
8) Domain2 не знаходить auth cookie і редіректить на сервер аутентифікації.
9) Сервер аутентифікації бачить auth cookie і не заставляє ще раз логінитись, редіректить на domain2 з токеном
10) Domain2 валідує токен і сеттає domain2 cookie.
11) При переході від domain1 до domain2 і навпаки, користувач буде аутентифікований, так як має domain1, domain2 cookies

Якщо authentication server створює jwt токен і для формування сигнатури використовує симетричне шифрування, всі сервери повинні мати shared key, щоб провалідувати сигнатуру токену, якщо асиметричне, то лише public key.

-------
       |
 OAuth |
       |
-------

Протокол авторизації, який дозволяє надати доступ до сервісу від імені користувача іншому сервісу без розкривання login credentials користувача(password).
Ролі:
Resource Owner - користувач ресурсу, що надає доступ до нього
Resource Server - сервер ресурсу, доступ до якого намагають отримати
Client - сервіс(застосунок), що запитує у Resource Onwer доступ до ресурсу
Authorization Endpoint - сервер, авторизує доступ на певні дії над ресурсом. При Implicit flow ще видає access token.
Token endpoint - використовується для отримання токену (Authorization code, client cred, resource owner pass cred flows), окрім Implicit flow
Access token - це стрічка, що містить надані дозволи на виконання над ресурсом. Переважно це JWT token, який може бути зашифрований, так як Сlient не потрібно знати, що він містить, лиш віддати Resource Server для отримання доступу. 
Access token - opaque string, short-lived. Refresh token - long-lived token для отримання нового access & refresh token.
При запиті на доступ Сlient вказує scope дій, які хоче здійснювати над ресурсом, які має підтвердити Resource Owner.

Існує п'ять flow отримання доступу(response_type):
1) Authorization Code - для Client з присутньою backend частиною. Так як для цього flow треба передавати Client Secret, то SPA не підходить цей flow, зберегти безпечно secret не вийде.
2) Authorization Code Flow with Proof Key for Code Exchange - для мобільних застосунків, які не можуть зберегти приватно client secret, через декомпіляцію можна його дістати.
3) Implicit - для SPA(single-page applications), де виконуєтсья на клієнтському коді(Javascript) у браузері Resource Owner. Refresh token недоступний
4) Resource Owner Password Credentials. Resource Owner передає свої креди Client, який у свою чергу отримує доступ до ресурсу. Використовується тільки для trusted apps, так як експоузить креди.
5) Client Credentials - machne-to-machine комунікація, авторизація Client, Resource Owner - це Сlient у цьому flow

Implicit виглядає легшим способом, так як немає проміжного коду для отримання токену, але refresh token недоступний, бо не може бути збережений приватно. Взамін можна налаштувати подальші отримання токену без логін пейджі і авторизації
доступу (prompt=none)

Authorization Code
1) Сlient редіректить Resource Owner на Authorization Endpoint
2) Resource Onwer аутентифікується. Після цього у нього запитують дозвіл на виконування переліку дій, що бажає здійснювати Client
3) Після згоди Authorization Endpoint редіректить Resource Owner з auth_code по redirect_uri Client, що було вкзано на етапі 1
4) Client посилає запит до token endpoint з auth_code, client_id, client_secret
5) Token endpoint валідує параметри і відповідає з access token, refresh token(optionally)

Authorization Code Flow with Proof Key for Code Exchange
1) Сlient генерує сryptographically-random code_verifier та з нього сode_challenge, редіректить Resource Owner на Authorization Endpoint з code_challenge
2) Resource Onwer аутентифікується. Після цього у нього запитують дозвіл на виконування переліку дій, що бажає здійснювати Client
3) Після згоди Authorization Endpoint зберігає сode_challenge та редіректить Resource Owner з auth_code по redirect_uri Client, що було вкзано на етапі 1
4) Client посилає запит до token endpoint з auth_code, code_verifier
5) Token endpoint валідує auth_code, code_verifier з code_challenge і відповідає з access token, refresh token(optionally)

Implicit (No refresh token)
1) Сlient редіректить Resource Owner на Authorization Endpoint
2) Resource Onwer аутентифікується. Після цього у нього запитують дозвіл на виконування переліку дій, що бажає здійснювати Client
3) Після згоди Authorization Endpoint редіректить Resource Owner з access token по redirect_uri Client, що було вкзано на етапі 1

Resource Owner Password Credentials
1) Resource Owner вводить на Client креди
2) Сlient відправляє креди на endpoint та отримує access token, refresh token(optionally)

Client Credentials
1) Client надсилає запит на token endpoint з client_id, client_secret і отримує acess token

Отримання нового access token using refresh token
1) Client ріквестить token endpoint з refresh token і отрмує новий access & refresh token

----------------
                |
 OpenID Connect |
                |
----------------

Протокол аутентифікацію на основі OAuth2. Делегує аутентифікацію Identity Provideer'ам(Google, Facebook, Twitter, custom..) та повертає ID token з інформацією про Resource Owner.
Так як це прошарок над OAuth, можна отримувати access token & refresh. Використовується в Single Sign-On. ID token представляє собою JWT token. Також ID token можна обміняти на access token на token endpoint.
Standart claims: jwt claims(sub(identity), iss(IdentityProv), aud(client)....others) + name, family_name, given_name, middle_name, nickname, picture, updated_at, email, phone.
Flow:
1) Authorization code
2) Implicit
3) Hybrid - дозволяє frontend & backend отримувати токен роздільно
UserInfo Endpoint - використовується для отримання додаткових даних про identity

------------
            |
 Asymmetric |
            |
------------

Тип шифрування, при якому використовується пара ключів: публічний і приватний. Публічний ключ видається кожному, хто хочеш встановити приватну розмову, а приватний ключ зберігаєтсья у безпеці.
Так як пара математично пов'язана, зашифроване повідомлення публічним ключем можна розшифрувати лише за допомогою приватного ключа, і навпаки, зашифроване повідомлення приватним ключем, може розшифрувати будь-хто у кого є публічний ключ.
Нехай Bob хоче посилати повідомлення Alice, щоб ніхто не зміг зрозуміти його вміст.
Bob і Alice обмінються публічними ключами і шифруютсья повідомлення публічними ключами один одного, та розшифровують власними приватними ключами. Якщо хтось перехопить повідомлення, то вміст повідомлення не буде розкрито,
до поки приватний ключ у таємниці.
Ассиметричне шифрування займає більше часу і використовує більше часу CPU, тому використовується переважно для аутентифікації(digital certificate) та встановлення shared key(symmetric).
Такожн використовуєтсья при формуванні digital signature.
Важливим фактором безпеки являєтсья розмір кллюча, мінімум -  1024-bits, краще - 2048

Переваги:
1) No key agreement. Проста і безпечна передача Public key будь-кому.
2) Лиш одна сторона має зберігати ключ у безпеці(server his private key)

Недоілки:
1) Більш повільне шифрування/дешифрування, нід у symmetric
2) Великий розмір ключа, так як публічний ключ досутпний будь-кому.
3) Без certificate не можна точно сказати чи публічний ключ належить тому, до кого ми хочемо звератитсь

Trapdoor function - easy to compute in one direction, but almost imposible in antoher way(one way function), at least you know secret(trapdoor)
Trapdoor function = one-way function + trapdoor
Hash = one-way function

-----------
           |
 Symmetric |
           |
-----------

Тип шифрування, у якому використовується один і то й же ключ для шифрування та дешифрування. Для цього ключем необхідно обмінятись або узгодини на всіх сторонах. Обмін ключем(key exchange) по незашищеному каналі приведе до його
експоузання, тому найкращий варіант узгодити ключ(key agreement). Через те що використовуєтсья один ключ, процес шифрування/дешифрування швидкий.
Розмір ключа 128-256 bit

Переваги:
1) Швидший процес шифрування/дешифрування
2) Менший розмір ключа

Недоілки:
1) Key exchange or agreement
2) Обидві сторони повині зберігати ключ у безпеці

--------------------------
                          |
 MAC vs Digital signature |
                          |
--------------------------

Повідомлення пропускається через хеш функцію і отримує стрічку фіксованого розміру, що потім шифрується за допомогою приватного ключа(digital signature & assymetric encr)
чи shared key(MAC & symmetric) та додається до повідомлення. Клієнт, отримавши повідомлення, отримує хеш, скормивши хеш функції повідомлення, та порівнює його з хешом, що прийшов від
сервера і був дешифрований за допомогою публічного ключа(Digital signature) чи shared key(MAC).

Обоє забезпечують:
1) Data integrity - prevents tampering, дані не були підмінені під час трансміту, так як приватний ключ або shared key знає тільки сервер
2) Authentication - володіння приватним ключем або shared key, що зашифрував повідомлення, означає, що сторона виявляється тим за кого себе видає

Digital ще включає non repudiation - сервер не може спростувати, що саме він надсилав повідомлення, так як хеш шифрувався за допомогою приватного ключа і ніхто, окрім сервера, не має його
знати, а спростовуання значить, що приватий ключ був скомпроментовано.

Шифрувати хеш, а не всі дані краще, так як хеш меншого розміру.

--------------------------
                          |
 Diffie-Hellman Algorithm |
                          |
--------------------------

Дозволяє учасникам безпечно створити shared key через незахищену мережу. Сторони обмінюються публічними змінами, які поєднують з приватними, і разом створюють ключ, за допомогою якого будуть шифрувати та дешифровувати повідомлення.
У створенні можуть приймати від 2 і більше сторін.
Приклад на кольорах:
1) Обидві сторони вирішили, що за основу вони будуть брати колір жовтий
2) Кожна з сторін придумує свій секретний колір, який вона триматиме не озголошеним
3) Кожна з сторін додає до жовтого свій секретний колір та обмінюються результатами
4) Після обміну обидві сторони знову додають свій секретний колір та отримують одинаковий результат
Не знаючи секретні кольори, зловмисник не може створити такий же колір в кінці.

Обидві сторони узгоджують два числа модуль p - велике просте число, основу g  - менше число та генерують свої secret numbers a & b, які між 1 та p.
Перша сторона обчислює A = (g^a) mod p, друга B = (g^b) mod p, та обмінюються результами. Після перша сторона підносить результат B до степені свого secret number a і до mod p, друга сторона теж саме, але до степеня свого secret number b.
Так обидві сторони отримують одинаковий результат, а проміжних даних, якими вони обмінювались через незахищену мережу, недостатньо зловмиснику, що отримати також shared secret, так як він не знає числа a & b.
Якщо число n мале, то через n-спроб brut force ключ буде зкомпроментовано.
Після цього shared secret пропускаєтсья через key derivation function і результатом стає shared key у обидвох сторін.
Сам по собі DH вразливий до MITM атаки, так як немає механізму аутентифікації. Клієнт встановлює shared key з MITM, MITM з cервером. Тому часто використовується з digital certificates і signature.

Також DH може використовуватись для створення public/private key, так як secret number кожного буде приватним ключем, а кінцевий результат публічним. Цей підхід не використовується, так як не може застосовуватись з digital certificate,
тому RSA краще.

-----
     |
 TLS |
     |
-----

Протокол, який забезпечує безпечне з'єднання. Повідомлення шифруються за допомогою shared key(symmetric encryption), який було створено під час TLS handshake.
Шифрування за допомогою shared key швидше, ніж за допомогою публічного та приватного ключа, тому вони використовуютсья лише на етапі handshake для аутентифікації сервера
(у публічному сертифікаті вказаний домен і якщо він співпадає з доменом на який йде ріквест, то все окі, хоча man in the midlle може перехопити ріквест і відпавити оригінальний сертифікат,
розшифрувати повідомлення він не зможе, бо не володіє приватним ключем) та безпечного передачі даних на цьому етапі (у сертифікаті є публічний ключ і лише холдер приватного ключа може
розшифрувати повідомлення), так як shared key ще не сформовано.
TLS не захищає від перехвату повідомлень, але ці повідомлення зловмисник не зможе розшифрувати.
Якщо вибрано key exhange алгоритм(key agreement) ephemeral Diffie-Hellman чи ephemeral elliptic-curve Diffie–Hellman, TLS забезпечує forward secrecy - властивість, при якій, 
якщо приватний ключ буде заекспоузаний, повідомлення з попередніх сесій не можна буде розшифрувати(якщо їх зловмисник зберігав) 
Data integrity(prevent tampering) - до кожного повідомлення прикріпляється MAC(mesage authenctication code) і зміна повідомлення буде виялена.
Результат хешфункції на повідомлення енкриптиться за допомогою shared key і передається клієнтові, той у свою чергу рахує хеш повідомлення власноруч і звіряє з дешифрованим хешом cервера.
Якщо не співпадає, повідомлення було підменено.
Cхоже до digital signature, тільки там для шифрування використовується приватний ключ, а для розшифрування - публічний.
Handshake встановлює з'єднання, узгоджує який cipher suite(key establishment(RSA/DH), authentication,confidentiality (a symmetric cipher),integrity (a hash function)) і версію tls
використовувати(найвищу, яку обидва підтримують), підтверджує, що клієнт розмовляє саме з тим сервером з яким бажав, а не з man in the middle(Зеленський!??!?!), аутентифікація клієнта
необов'язкова, але може бути форсанута, створення shared(master) key для подальшого шифрування.
RSA Handshake:
1) Клієнт посилає ClientHello до сервера з найвищою версією TLS, яку підтримує, список підтримуваних chiper suit(chipher algorithms and hash functions) та методів компресії, client random number(32-byte).
2) Cервер відповідає з ServerHello, вибраною найвищою версією TLS, що обоє підтримують, вибраний найнадійнішим зі списку chiper suite та метод компресії(до TLS 1.3) та server random number.
3) Cервер надсилає cертифікат і дуже рідко може потребувати сертифікат у клієнта
4) Сервер надсилає ServerHelloDone
5) Клієнт надсилає Client Key Exchange повідомлення з зашифрованим за допомогою публічного ключа сервера pre-mastered key. Розшифрувавши приватним ключем, сервер передає у
key derivation function(pseudorandom function) premastered key, client-server random numbers і отримує три ключі - write key, write MAC key, write IV.
Клієнт викликає функцію з тими ж параметрами і отримує ті ж ключі.
6) Клієнт посилає Client Change Cipher Spec, що означає початок симетричного шифрування при спілкуванні.
7) Клієнт посилає зашифроване Finish повідомлення, яке серввер має успішно розшифрувати за допомогою shared key.
8) Cервер надсилає повідомлення Server Change Cipher Spec 
9) Cервер посилає зашифроване Finish повідомлення, яке клієнт має успішно розшифрувати за допомогою shared key.

Недолік цього RSA handshake, якщо приватний ключ буде експознутий, то premastered key буде скомпрометовано і сесію можна буде рошифрувати(missing forward secrecy).

DH Handshake:
1) Такий же як і RSA Handshake
2) Такий же як і RSA Handshake
3) Сервер надсилає повідомлення Server Key Exchange з обраними DH параметрами та для аутентифікації надсилає digital sigantures попередніх повідомлень
4) Клієнт валідує digital signatures і надсилає Сlient Key Exchange з DH параметром.
5) Учасники генерують ключі
6-9 the same

-------
       |
 OWASP |
       |
-------

1) Injection

Вразливості, пов'язані з впровадженням SQL, NoSQL, OS и LDAP, виникають, коли непровірені дані відправляються інтерпретатору в складі запиту. Шкідливі дані можуть заставити інтерпретатора
виконати непередбачувані команди або отримати доступ до даних без відповідної авторизації.

SQL, NoSql, LDAP, XPath - queries, OS commands
Коли через вхідні дані(query string, form data, headers, cookies) можна передати код(untrasted data), який cпричине невалідну роботу системи. Untrasted data не має конкатинуватись у запити, а використовуватись у параметризації.
Entity Framework підтримує параметризацію з коробки.
'SELECT * FROM WHERE ID = ' + untrasted data - WRONG
'SELECT * FROM WHERE ID = @ID' @ID = untrasted data - RIGHT
Параметризація в stored procedure не захищає від injction, якщо вібувається конкатенація стрічкового запису до параметру(exec, instead use sp_executesql with param)

Вирішення:
a) Параметризація(escaped properly, type cast)б
b) ORM Frameworks
c) Whitelist validation
d) Principle of least privileges. Давати юзеру лиш наймінімальніший доступ. Лиш до певних таблиць, лиш на певні дії(select).


2) Broken Authentication

Функції застосунку, пов'язані з аутентифікацію та управління сесією, часто некоректно реалізовані, що дозволяє зловмиснику скомпрометувати паролі, ключі, сесійні токени, а такоє експлоатувати
інші помилки реалізації для тимчасового або постійного перехвату облікових записів користувачів.

Неправильно реалізована аутентифікація чи session management призводить до того, що зловмисник отримує доступ до акаунту.

Session hijacking:
1) Session fixation - коли зовмисник просетує значення session id через XSS чи у міститься у лінці. Після аутентифікації користувача, зловмисник може використати цей id,
щоб отримати досутп до аккаунту
Вирішення: перегенеровувати session id після успішної аутентифікації

2) Session side jacking - зловмисник зчитує незашифровану куку і отримує session id.
Вирішення: encryption, Secure cokke attribute 

3) XSS - зловмисник розміщує скріпт, який відправляє session id на його сайт
Вирішення: HTTPOnly cookie атрибут

4) Вгадування session id
Вирішення: session id має бути довгою стрічкою

a) Реагування на brute force
b) Забороняти слабкі паролі, blacklist well-knowed passwords
c) Шифрування(TLS)
d) Не експоузити session id in URL(loging, history, copy-paste)
e) Невірно налаштовано session timeout - чим більше вікно, тим більше шанс, що сесія буде викрадена і нею будуть користуватись довше.
Sliding - експайриться через певний час неактивності. Fixed - заекспайриться рівно через x min
f) Зберігати у базі хеш паролю, використовувати сіль

3) Sensitive Data Exposure

Багато застосунків та API мають недостатній рівень захисту фінанових, медичних чи персональних даних. Зловмисники можуть викрасти або змінити ці дані, а потім виконати махінаційні дії з
кредитними або персональними даними. Конфіденційні дані потребують додаткових мір захисту, наприклад шифрування при передачі та збережені.

a) Не зберігати персональні дані без необхідності, видааляти одразу як перестали бути потрібні
b) Шифрування(TLS)
C) XSS, insecure storage, broken auth & session management

4) XML External Enities

Експлуатація вразливих XML-обробників, впроваджуючи вредоносний контент в XML-документ, що дозволяє виконувати віддалені команди на сервері.
XML-документ завантажується на сервер і там виконуються команди, що були оголошені в external entity, що дає можливість виконувати ряд дій на веб-сервірі, які призведуть до розголошення та 
втрати даних, зупинки веб-сервера та інше.

Старі або невірно налаштовані XML-процесори обробляють посилання на зовніщні сутності всередині документу. Ці сутності можуть бути використані для доступу до файлів, сканування портів,
віддаленого виконування коду, відмови роботи веб-сервера.

Вирішення:
a) проапдейтити XML процессор, де XXE буде вимкнуто, або вимкнути вручну XXE
b) використовувати інші формати

5) Broken Access Contorl

Дії, дозволені аутентифікованим та аутеризованим користувачам, часто недостатньо контролюються. Зловмисники можуть скористатись цим і отримати несанкціонований досуп до облікових записів
інших користувачів чи конфіденційної інформації, а також змінювати дані користувачів чи права доступу.

Переважно авторизовані користувачі через маніпуляцією параметрів(insecure direct object reference) запиту можуть отримати доступ до інформації інших користувачів.
Так як весь функціонал міститься на сторніці у браузері, через зміну markup сторінки можна тримати доступ до адмін панелі.

a) Необхідно реалізовувати додаткову авторизацію на бекенді, щоб прівентити ці кейси. if (User.UserID != userID)
b) Реалізувати indirect object reference. Зберігати у сесії map з direct OR в indirect OR

6) Security Misconfiguration

Вразливість, при якій будь-який компонент у системі, від сервера до бази, налаштований некоректно, що призводить до виникнення пробоїни у безпеці.
Необхідно правильно налаштофувати OS, фреймворки та вчасно їх апдейтити. Не експоузити внутрнішню реалізації під час виникненян помилок у системі.
Шифрувати sensitive data(connection strings in web.config). Заборонити навігування до папок.

7) Cross-Site Scripting

XSS має місце, коли застосунок добавляє непровірені дані на веб-сторінку без здійснення відповідної провірки чи перетворення. За допомогою XSS зловмисники можуть виконувати сценарії
в браузері жервти, що дозволяються їм перехоплювати користувацькі сесії, підмінювати сторінки сайту чи перенаправляти на вредоносні сайти.

Коли дані, які відображаються на сторінці, ламають markup і дозволяють його змінювати, inject'ити скріпти, які можуть змінювати представлення або відправляти персональні, сесійні дані.
Reflective, Stored, DOM-based XSS

Вирішення:
a) Output Encoding, в залжності де дані відображаються, енкодиди до того середовища.
System.Web.Securty.AntiXXS AntiXSSEncoder.HTMLEncode(data)
ASP.NET Web Forms деякі контроли впроваджують енкодінг. RequestValidaton prtects from suspicious data income
ASP.NET MVC Razor engine encodes html by default(HTML Helpers). Attribute AllowHTML, @Html.Raw disable encoding
b) Whitelisting
c) HTTPOnly cookie flag, куки не доступні з script language(Javascript)
d) Content Security Policy дозволяє завантажувати контент лише з дозволених origin. Якщо js code не з файлу, то блокає
e) Native browser defences

8) Insecure Deserialization

Об'єкти при відправлені на клієнт десеріалізується(token for example). При повернені його на сервер, дані можуть бути змінені з намірами отримання несанкціанованого доступу
(role change to admin) чи виконання коду. Для запобігання необхідно підтвердити цілісність даних за допомгою MAC або digital signature.


9) Using Components with Known Fulnerabilities

Компоненты, такие как библиотеки, фреймворки и программные модули, запускаются с
привилегиями приложения. Эксплуатация уязвимого компонента может привести к потере
данных или перехвату контроля над сервером. Использование приложениями и API
компонентов с известными уязвимостями может нарушить защиту приложения и привести
к серьезным последствиям. \

У CDCI pipline при перевірці dependency checker, якщо компоненти містять вразливість, необхідно переривати білд, якщо just outdated - warn

10) Insufficient Logging & Monitoring

Недостатки журналирования и мониторинга, а также отсутствие или неэффективное
использование системы реагирования на инциденты, позволяет злоумышленникам
развить атаку, скрыть свое присутствие и проникнуть в другие системы, а также изменить,
извлечь или уничтожить данные. Проникновение в систему обычно обнаруживают только
через 200 дней и, как правило, сторонние исследователи, а не в рамках внутренних
проверок или мониторинга. 

Additional

a) СSRF

Use antiforgery token
Same Site cookie flag - sends cookies only if origin is the same as requesting site

b) Insecure Cryptographic Storage

Пароль не повинен зберігатись у plain text, лиш його хеш. При логінені пароль хешується та звіряється на відповідність з тим, що збережений у базі. Існує безліч password dictionary, що містять common passwords. Ці паролі хешуються та
використовуються для порівняння та отримання паролю(brute force, hash cracking tools: hashcat, google). Rainbow table - дуже великий файл(60-900GB) з прекалькульованими хешами. Tool: RainbowCrack
Щоб уникнути вразливості передбачуваності хешу, використовується сіль. Сіль - це послідовність рандомних байтів, що додаються до паролю перед хешуванням. Пароль зі сіллю все ще можна крякнути, але це займе значно більше часу.
Не можна забезпечити 100% сесюрність, все зводиться до того, щоб скористатися вразливістю було дуже складно. Перехешовувати можна безліч кількість раз, але це вдарить по performance застосунку, тому треба знаходити золоту середину.
Сіль зберігається поруч з хешом, щоб процес міг повторитись, коли користувач буде логінитись. Одинаковий пароль + різ ні солі = різні хеші.
Важливим аспеком також являється повторне хешування хешу, що удвічі займає більше часу. Кількість повторів може бути довільна, але це значно навантажує CPU, і вппралель логінення 100 корисутвачів значно вдарить по продуктивності.
Також зловмисник може використати автоматизовану атаку на сервер, логітись під існуючими аккаунтами, щоб сервер калькулював хеш, хоч і пароль може бути невірний.
Ми бажаємо, що застосунок працював якомога швидше, якщо це відноситься до калькулювання хешів, то якомога повільніше, тому що це заповільнить і їх взламування. При калькулювані хешів у застосунку ми використовуємо CPU, зловмисники при
взломі паролів - GPU, що дає їм значну перевагу у швидкості. Також варто не забувати, що при зміні алгоритму шехування, збережені паролі будуть втрачені.

--------------
              |
 SAST vs DAST |
              |
--------------

Методологія для пошуку вразливостей у безпеці застосунку.
Static application security testing - white box method of testing, while Dynamic applciation security testing is black box.
SAST предназначений для інстекції коду програми на предмет виявлення вразливостей, у той час як DAST інтспектує running program.
Існують SAST & DAST tools, які здійснюються аналіз ПЗ, та можливо інтегрувати їх у CI/CD